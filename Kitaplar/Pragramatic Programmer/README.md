Bu kitapta ki konu başlıklarını özetler nitelikte, kendimden cümlelerle yazmaya çalıştım. Kitabı okumanızı muhakkak tavsiye ediyorum.

# Pragmatic Programmer

Pragmatik Bir Programcı Ne Yapar?

Her yazılımcı kendi stilini bir gün bulacak ve bunlar; hobiler, kıyaflet kadar keskin olacak. Ancak, pragmatik bir programcıysanız şu özelliklere sahip olmalısınız:

1. Hızlı adapte olabilme
2. Meraklı
3. Kritik noktaları düşünebilme
4. Gerçekçi
5. Her işte usta olabilme

Sadece bir konuda uzman değil, yeni bir konuda da rahatça uzmanlaşabilmeli ve hızlı adapte olabilmesi lazım bir pragmatik programcının. Yeni bir şeyler öğrenme konusunda her zaman meraklı olabilmeli ve herkesin aklına gelmeyecek şeyleri de düşünebilmeli ve araştırabilmelidir. Son derece gerçekçi olmalıdır. Bir proje ne zaman biter ya da ne gibi zorluklarla yönetilebilir.

1. Yaptığımız işi önemsemek
2. Yaptığımız işi düşünmek

Önemseyeceğiz ki, sadece kod yazan bir yazılımcı olmak istemiyoruz. İstiyoruz ki daha iyi bir yazılımcı olabilmek. Öyleyse yaptığımız işleri düşüneceğiz. Düşüneceğiz ki, daha iyi bir yazılımcı olalım. Bu kitapta düşünmeyi öğreneceğiz.

## Chapter 1 - A Pragmatic Philosophy

### Topic 1. It's Your Life

Bruce Lee - ***I'm not in this world to live up to your expectations and you're not in this world to live up to mine*** Ben bu dünyaya senin beklentilerini karşılamak için gelmedim. Sen de benimkilerini karşılamak için gelmedin.

Hayatınızı düşünün. Eleştirdiğiniz şeyleri düşünün. Ne kadarı sizin üzerinizde etkili, ne kadarını değiştirebilir ne kadarını değiştiremezsiniz. Eğer hayattan zevk almak istiyorsanız, sizi üzen şeyleri terk etmelisiniz. Yazılım sektörü çok fazla imkan sunarken, sizin imkanızı kısıtlayan şeyleri engellemelisiniz. Sizi üzen şeyleri hayattan çıkarmalısınız. Risk almalısınız ve kararınızı sonuna kadar desteklemelisiniz. Evet hayat bazen çok acı verici oluyor ancak ayağa kalkabilmeli ve savaşmalısınız.

Sadece şunu unutmayın. Ne konuda acı çektiğinize dikkat edin. Acı çektiğiniz şey, sizi güçlendiren bir şey mi, yoksa boşa mı kürek çekiyorsunuz.

### Topic 2. The Cat Ate My Source Code

J.B. Bossuet, Politics from Holy Writ, 1709 - ***The greatest of all weaknesses is the fear appearing weak*** Zayıflıkların en büyüğü, zayıf görünme korkusudur.

Sorumluluk bilinci birçok şeyin üstündedir. Eğer bir göreviniz varsa ve bunu yapacağım dediyseniz onu yapmakla mükellefsiniz. Zorluklar olabilir ancak buna uygun bir yol haritası çizilmeli ve son sürat hedefe doğru koşulmalıdır.

Eğer ortada bir hata varsa, bir kötü durum söz konusuysa üzerinize sorumluluk almayı bilin. Başkasını eleştirmek, başkası üzerinden prim yaparak haklı çıkmaya çalışmak son derece yanlış şeyler. Eğer ortada büyük bir iş söz konusuysa üzerine düşen sorumluklar ile ortaya çıkıp insanlara bir şeyler anlatmaya çalış. Ben işin bu tarafını tutarım de ama asla bir köşeye geçip yan gelip yatma.

Bilmiyorum demek işin en kolay yanı. Pragramatic Programmer bilmiyorum kelimesinin yanında *ama öğreneceğim* der ve devamında profosyonel bir sorumluluk alır.

**Challenges**

Eğer bir banka memuru, bir oto tamircisi ya da bir katip topal bir hata ile karşıma çıkarsa, onlar hakkında ne düşünürsünüz adlı bir soru var konu sonunda. Bu soruyu Türkiye'de on mesleğin dokuzunda gördüğümüz için sadece Teşekkürler diye cevap vererek geçiyorum çünkü yapaleceğimiz bir şey yok. İşte sırf bu sebeple biz bazı şeylerin farkında olan gençler olarak, eğer ortada yanlış bir şey varsa onu kabullenip sonuç üretme mekanizmalı olmalıyız. İşte sırf bu sebeple onların dili eğer kötüyse biz iyi olmalıyız.

### Topic 3 - Software Entropy

Entropi bir sistemde ki düzensizlik miktarını ifade eden bir terimdir. (Sanırsam bu terimi en son lise yıllarımda duydum 🫠) Ancak konuyla bağdaştırınca ne kadarda mantıklı bir yorum haline geliyor. Bizim dilimizde çok güzel bir atasözü var. Üzüm üzüme baka baka kararır diye. Bu cümleyi hiç yazılımla bağdaştırdınız mı?

Eğer bir projede kötü tasarımlar, yanlış kararlar ya da zayıf kodlar varsa ve bunların çözümü için de çözümler tartışılmıyorsa zamanla üzümlerin yavaş yavaş kararması gibi tüm bir projede zamanla körelmeye ve işlevsel olmamaya başlayacaktır.

Çözümler üretilmeli, çözebilecek durum söz konusu değilse  tahtaya yazılıp fikirler tartılışmalı her gün. 

Eğer kendinizi tüm tarafları patlamış bir projenin içerisinde bulursanız, bende onların bu şekilde yazdığı kod gibi yazmaya devam edim, demek çok kolaydır. (Emin olun çok kolay 🥲 Tecrübeyle sabit) Bunun yerine çözümler üretebilmeli ve ortaya bir mimari çıkartabilmek gerekmektedir. Değişimler zordur ancak bir kez değiştikten sonra kimse eskiyi hatırlamamaktadır. Bu konuda birkaç kırık pencere belirleyin ve meslektaşlarınızla durumu tartışın.

**Challenges**

İlk karşılaştığım kırık pencere deneyimi soruyor. Tepkim nasıldı vs. Emin olun hiçbir tepkim olmadı. Ben pandemi öğrencisi oldum. 1. sınıf ve 2. sınıfım pandemide kötü geçti. Kendimi geliştiremedim. 3. sınıfta çalışma hayatı yaşadım ve orada düzensizlik içerisindeyim. Algoritma kurma konusunda bile zorluklar çekerken mimari açıdan kod yazmak hiç bilmiyordum ve bir anda kendimi bir sayfada 3000 - 4000 kodların yazıldığı, design patternlerin, mimarilerin kullanılmadığı bir iş tecrübesi içerisinde oldum. Bu belkide hayatım boyunca hiç unutmayacağım bir tecrübe oldu. Zaten kısa süreli çalıştım ve çıkışım yapıldı. (Birkaç ay)

### Topic 4. Stone Soup and Boiled Frogs

Matrix serisi ilk nasıl çekilmeye başladığını biliyor musunuz? Warner Bros'la görüşmeye gidiyorlar Wachowski kardeşler. Ancak Warner Bros sıcak bakmıyor ve Wachowski kardeşler ısrarcı olduklarında Warner Bros çekelim bu filmi dediklerinde Wachowski kardeşler 80 milyon dolar para istemiş. Warner Bros olur mu ya öyle şey, yuh o para ne. Alın size 10 milyon dolar demiş. Wachowski kardeşler de o parayla sadece ilk 10 dakikayı yapıp göndermişler. Günün sonunda nolmuş derseniz, Warner Bros hayran kalıyor ve istenilen paradan daha fazlasını veriyor.

İşte bazen aynı bu örnekte olduğu gibi kendimize güvenmemiz gerekiyor. Eğer kendimize sonuna kadar inandığımız bir konu varsa, bazen izin almakla, cartla curtla uğraşmayı beklemek anlamsızdır. Üstümüzde ki insanlar sadece başarıyı odak alan insanlar olurlar genellikle. Onların karşısına bir şeyleri yapıp gittiğiniz de, başarınıza ortak olurlar ama şöyle yapıcam, böyle edicem derseniz pek bir anlamı yok maalesef.

Eğer hiçbir şey olmamış gibi devam ederseniz yavaş yavaş sistemin bir kölesi olursunuz. O kadar emin olarak ilerdiğiniz proje, ellerinizden kayıp gider. Günün sonunda mutsuz bir kişilik olur çıkarsınız.

Şuan etrafınızda ne var, üstünüzde kaç ışık kaynağı var, şuan bulunduğunuz odada nerede ne var gibi sorularla etrafınıza inceleyici gözlerle bakmaya çalışın. Etrafınızda olan bitenlere ne kadar hakim olabildiğinizi inceleyin. Aynı şekilde projede de hakim olmaya çalışın. Projeyi benimseyin elinizden geldiğince.

### Topic 5 - Good-Enough Software

Sayfa 50

Shakespeare - ***Striving to better, oft we mar what’s well.*** Daha iyisini çabalarken çoğu zaman iyi olanı bozarız.

Bir müşteri var ve bir ürün talep ediyor. Şu tarihe kadar yetişmesi lazım diyor. Siz eğer şu şu şu özelliklerde olsun derseniz belki ya süreyi yetiştiremeyeceksiniz ya da temel mühendislik kurallarından çıkacak ve yarım bir proje vereceksiniz. Bu hiç profosyonelce bir davranış değil.

Projeyi bir pragrametic programmer olarak yönetmeli ve erken denemesi için bir şeyler sunabilirseniz, bu size geri dönüt noktasında güzel bildirimler sağlayacaktır.

Projelerimizde mimari yapılar uygulamak güzel bir şeydir ancak her projede olmasına gerek yok. Küçük bir projede uygulanması, projeyi gereksiz kafa karışıklığna sebebiyet verecek, proje büyük bir projeyse uygulayın. Gereksiz çok süslemelere hiç gerek yok.

**Challenges**

Yazılım dillerinde, editorlerde, hatta işletim sistemlerinde tüm hataların giderilmiş olmasını beklemeyi mi, karmaşık yazılımların olduğunu ve bazı hataların çözümü yok denilerek kabul edilmesini mi yoksa daha az kusurlu daha basit yazılımları mı tercih edersiniz diye bir soru sorulmuş. Bu soruyu okuduğum zamanlarda ise (31 Ekim 2022) MacOS Ventura işletim sistemi yeni yayınlanmıştı. Bir kaç gün oldu daha. Bazen bilgisayarda sorunlar çıkabiliyor, donma kasma yapabiliyor. Peki bu bir sorun mu, bence hayır. Çünkü kelimenin tek anlamıyla mükemmeli beklemek çok yanlış onun yerine basit hatalar olsa da zamanla çözülebiliyor olması bence yeterli benim için. Yeni güncellemelerle bu sorunlarda gidecek. Ancak hiçbir zaman kusursuz olmayacak.


Diğer bir soru modüleştirme üzerine bir soru soru. Bir projede modüleştirmenin önemli olup olmadığını soruyor. Tabiki de modüleştirme son derece önemli. Bir sayfada 3000 satır kod olması neye yarar, neye çözüm getirebilir? Onun yerine parça parça olsa, yazılan kodları tekrar tekrar tekrar yazmasa projeyi yönetmek çok daha kolay olacak.

Son soruda, 'feature bloat' denilen özellik şişkinliğine hiç rastladın mı tarzında bir soru. Ne demek bu? Mesela bir uygulamada binlerce özellik var ve sen sadece 10-15 tane özellik kullanıyorsun. Diğer her bir özelliğin getirdiği bir ram tüketme, bug oluşturma gibi sorunlar oluştururken sen hiç böyle bir duruma rastladın mı diye bir soru soruluyor. Bu sorunun cevabı elbetteki, evet! Bir telefonda binlerce özellik var ben sadece arama yapıyorum diyelim. Onun yerine 3310 alıp şarjımın 1 ay dayanması daha mantıklı sanki 🥹

### Topic 6 - Your Knowledge Portfolio

Benjamin Franklin - ***An investment in knowledge always pays the best interest*** En iyi faiz, bilgi birikimine yapılan yatırımdır.

Bilginiz sizin portfolyönüzdür. LinkedIn profiliniz, Github profiliniz hiç önemli değil bu sektörde. Şirketler sizin bilginize bakarak işe alır.

* Ciddi yatırımcılar düzenli yatırım yapar. -> alışkanlıklar olarak
* Çeşitlilik anahtar kelimedir. -> uzun dönem başarının
* Akıllı yatırımcılar, riskli ile yüksek kazançlı yatırımlar arasında dengelidir.
* Yatırımcılar düşük gelirli bir şeyden yüksek gelir elde etmeye çalışırlar.
* Portfolyöler düzenli olarak gözden geçirilir ve yeniden şekillenir.

Aslında bu cümleler her şeyi açıklamak için yeterli. Yatırım kendinizsiniz ve kendinize olan yatırımı iyi düşünün. Yatırım sadece dövize ya da hisse senetlerine yapılmaz. (Lafın gelişi diyorum 🤓 bende biliyorum Türkiye'de ev, araba almak çok karlı) En büyük yatırım kendinizsiniz ve mutluluğunuz, hayat kaliteniz buna bağlı.

**Hedefler**

1. Mesela her sene yeni bir dil öğrenin
2. Her ay düzenli teknik kitap okuyun
3. Siz normal kitap da okuyun
4. Ortamlara katılın (Konferans, seminer, bootcamp, sınıflar vs.)
5. Topluluklara katılın (Network ağı dediğimiz olay)
6. Farklı etkinliklere de katıl (iOS Developer'san Android etkinliklerine de katıl)
7. Güncelliğinizi koruyun (Düzenli olarak alanınızda çıkan haberleri, yenilikleri takip edin)

Önünüze fırsatlar çıkacak ancak o fırsatların değerlendirmek için kritik düşünmemiz gerekiyor. Peki Nasıl?

1. 5 neden sor. 5 açıdan neden cevabını değerlendir kendi içinde
2. Kim için yararlı?
3. İçeriği ne?
4. Ne zaman ve Nerede işe yarayacak?
5. Neden böyle bir problem var?

**Challenges**

Yeni bir dil öğrenmeye başla diyor bu hafta. Ancak ben de aşağı yukarı 2 aydır yeni bir dil öğrenmeye başladığım için direk geçiyorum 😉 (Dil tabiki Swift)

Yeni bir kitap okumaya başla ama önce bu kitabı bitir diyor. Elbette ki, zaten şuan bulunduğum [Vakıfbank iOS Bootcamp](https://github.com/ozturkomerfaruk/Patika-Vakifbank-iOS-Bootcamp/tree/master/Kitaplar) sürecinde bir de Clean Code kitabını okuyacağım için kabul ediyorum bunu da.

Bir kafede, bir toplulukta bir etkinliğe katıl diyor. Şuan yine bir bootcamp sürecinde olduğum için otomatik yine bu challenge'ı kabul ediyorum.

### Topic 7 - Communicate!

Mae West - ***I believe that it is better to be looked over than it is to be overlooked*** Göz ardı edilmektense, görmezden gelmenin daha iyi olduğuna inanıyorum.

Bir şirkette en önemli 7 unsur vardır. Bunlar:

1. İletişim
2. İletişim
3. İletişim
4. İletişim
5. İletişim
6. İletişim
7. İletişim

Bilmem anlatabildim mi? Gerçekten espiri niteliğinde bunları yazmıyorum. Bir projeye başlayacaksınız sıfırdan ve bunu büyük bir ekip içerisinde yapıyorsunuz diyelim. Ya mesela yeni Witcher oyununu siz yapacaksınız. Devasa bir oyundan bahsediyoruz. Burada sürekli ekip içerisi toplantılar düzenlenmeli, ses ekibi ayrı, UI Design ekibi ayrı (ve kendi içinde ayrı) Backend ekibi ayrı, frontend ekibi ayrı, satış ekibi ayrı, yönetme ekibi ayrı. Yani biraz düşünürseniz onlarca farklı alan ve her alanda kendi içerisinde ayrılmalardan bahsediyoruz. Bunlar kendi içerisinde iyi bir dinleyici, iyi bir konuşmacı (derdini anlatma konusunda) olmazlarsa bu oyun çıkabilir mi piyasaya? Ayrıca düşünün bunların hepsi tek bir oyun üzerinde çalışıyor. Ancak ses ekibi yazılım ekibiyle beraber uyumlu olmasa ses ekibi yanlış ses design belki yapabilir değil mi? İşte bu sebeple düşünmelisiniz ki, ortada büyük bir dökümantasyon lazım. Dökümantasyon olmadan OLMAAAZ!!!

Dökümantasyon öyle önemli bir şeydir ki, bu projede çalışan yüzlerce insan yarın işten ayrılsa, yeni gelecek yeni yüzlerce insan projeye kaldığı yerden direk başlayabilmesi lazım demektir. Dökümantasyonun olmadığı yerlerde ne oluyor biliyor musunuz? Bunu gözlerimle şahit oldum bir şirkette. İki yazılımcı aynı sayfa tasarımını birbirinden habersiz yapıyor niye dökümantasyon yok ki :) Dökümantasyon hazırlamıyorlar ki :) Farklı zaman dilimlerinde yapmışlar. Boşa vakit kaybı, boşa emek israfı.

**Challenges**

Kitap tavsiyeleri var:

[The Mythical ManMonth: Essays on Software Engineering](https://books.google.com.tr/books?id=Yq35BY5Fk3gC&printsec=frontcover&dq=The+Mythical+Man+Month:+Essays+on+Software+Engineering&hl=en&sa=X&redir_esc=y#v=onepage&q=The%20Mythical%20Man%20Month%3A%20Essays%20on%20Software%20Engineering&f=false)

[Peopleware: Productive Projects and Teams](https://books.google.com.tr/books?id=TVQUAAAAQBAJ&printsec=frontcover&dq=Peopleware:+Productive+Projects+and+Teams&hl=en&sa=X&redir_esc=y#v=onepage&q=Peopleware%3A%20Productive%20Projects%20and%20Teams&f=false)

[Dinosaur Brains: Dealing with All Those Impossible People at Work](https://books.google.com.tr/books?id=_hcJUGQNQi8C&q=Dinosaur+Brains:+Dealing+with+All+Those+Impossible+People+at+Work&dq=Dinosaur+Brains:+Dealing+with+All+Those+Impossible+People+at+Work&hl=en&sa=X&redir_esc=y)

## Chapter 2 - A Pragmatic Approach

İşte başlıyoruz en güzel kısımlara. Bu zamana kadar olan yerler herkesin zaten bildiği (ama bazı şirketlerin ısrarla yapmadığı şeylerdi) şimdi iyi bir yazılımcı olmaya çalışacağız.

### Topic 8 - The Essence of Good Design

Bir uygulama piyasaya çıktıysa ve kullanıcı sayısı fazlaysa, kodları iyi yazılmış demektir. Bu kadar basit mi? Elbette ki, önemli olan son kullanıcıya ulaşması değil mi 🤓 Ancak bir uygulama düşünün ve çok yavaş açılıyor insanlar bundan şikayetçi, burada sorun sizce internette midir yavaş olsun. Hayır uygulama kötü yazılmış demektir.

İyi bir kod yazdığınızın en önemli kanıtları;

* Okunması kolaydır
* Her kod parçacığı değiştirilebilirdir

Bazen her kod parçacığının değiştirilebilir olarak kurmak çok zahmetli olabiliyor ancak hiç önemli değil. Proje büyüdükçe bir şeylerin değiştirilmesi gerektiğini görünce çok kolay yapabiliyor olduğunu farkedeceksin. Ayrıca Unit Test yazmak da çok kolay oluyor.

**Challenges**

Ne düşünüyorsunuz tarzında bir soru var. Ben yaklaşık 1.5 sene Flutter ile uğraştım. Flutter belki de bu kısım için en zirve nokta bile olabilir. Her bir nesne bir Widget denilen yapıdan oluşuyor. Eğer bir kez tekrara düşmek isterseniz projenin belki 1000 farklı yerinde uzun uzadıya kod yazarsınız. Bu yüzden belki de parçalamak Flutter için çok önemli bir şeydir. Bu da benim her dilde alışkanlık haline getirdi. Fonksiyonel ve Nesne Tabana yönelik kod yazmak hayatın en önemli gerçekleridir benim için.

## Topic 9 - DRY - The Evils Of Duplication

Yazılımda baş ucu kelimeniz DRY - ***Don't Repeat Yourself*** olmalıdır. Bol bol fonksiyonerliğinizi artırın. Her şeyi demiyorum ama parçalanabilen her bir kod parçacığını fonksiyonerleştirin.


Ne demektir bu? Her bir yazılan ifade kesin, belirgin olmalı. Tekrara sebebiyet vermemeli. Farklı açılardan irdelenip, tekrarı sağlatmamalı. Test edilirken daha sonra sıkıntısız olmalı. 

***Mesele hatırlamak değil, ne zaman unutacağınız*** Sonra yaparız dediğiniz her şey, sonra yapılmaz!

Bu yözden dolayı DRY - Kod yazmaktan çok daha önemli. Ne kadar iyi yazılımcı olursanız olun, ne kadar aslan, kaplan olursanız olun bir kez DRY'a düşerseniz orada boğulursunuz.

Bu konuyla ilgili bir tane kitap tavsiye ediyor yazar. Nesne taban olarak kodu parçalamak ne demek, fonksiyonerlik olarak parçalamak ne demek detaylı olarak oraya referans ediyor. 

[Object-Oriented Software Construction.](https://books.google.com.tr/books?id=xls_AQAAIAAJ&q=Object-Oriented+Software+Construction.&dq=Object-Oriented+Software+Construction.&hl=en&sa=X&redir_esc=y)

### Topic 10 - Orthogonality

Yazarın kitap tavsiyesi var. [Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design](https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719)

Ortogonal sistem aslında MVVM, MVC, VIPER gibi design patternlerin önemini anlatıyor. Herbir tarafı blok blok yazmanın önemini anlatıyor. Bunun üç açıdan önemi var.

1. Üretkenliği artırmak

Test yazması daha kolay, tekrar kodlanması, tasarım yapılması vs. daha kolay oluyor. Ayrıca eğer kod yazılırken ortogonal şekilde yazılırsa, iki parça ayrı ayrı olduğunda, farklı yerlere vs. kullanmakta daha kolay uyum sağlatır. Öbür türlü bir sayfada 3 bin satır koda doğru merhabaaa!

2. Riski azaltır

Test edilmesi daha kolay cümlesini biraz açacak olursak. Bir kere bir projede test yazmanın önemi çok fazla olduğunu vurgulamıştık. Peki test yazarken nasıl yazacağız? İşte ortogonal bir sistemde test yazacağız. Test yazmanın önemi en çok bu noktada anlaşılıyor. Eğer blok blok her bir kod parçacığı ayrılarak ilerleniyorsa test hem daha kısa sürede yazılır hemde daha başarılı sonuçlar elde ederiz. Öbür türlü durum çok daha karmaşık, çok daha kötü yere gidiyor.

3. Dökümantasyon hazırlanması

İki kardeşin yaşadığı bir ev düşünün. Birinci kardeş, çok düzenli birisi olsun diğeri dağınık. Dağınık olan oda da her şey her yerde iken düzenli odada çamaşırlar dolapta, kitaplar kitaplıkta vs. olsun. Sizin göreviniz iki odaya girip küçük bir kalem pil almak olacak. Hangisinden daha kolay alabilirsiniz sizce?

İşte dökümantasyonun önemi de aynen bu şekilde. Eğer siz 3 bin satırın olduğu onlarca sayfaya girip tek bir sınıftan türeyen nesneye ulaşmaya çalışıyorsanız vay halinize! Ama bütün kodlar blok blok ayrılsa, isterse bin tane sayfa olsa. Ama ayrı ayrı sayfaları dökümantasyon oluşturmak daha kolay. Çok daha hızlı bulursunuz. Zaten 3 bin satırlı onlarca sayfaları kimse dökümantasyon oluşturmaya çalışmıyor. Nasıl edebilirsin ki zaten? Kodlar hep **DRY** prensiplerinden uzak, hiçbir mimari, design pattern yok her şey karmakarışık bide oturup döküman mı hazırlayacan! mehhh! 

### Topic 11 - Reversibility

Emil - Auguste Chartier **Nothing is more dangerous than an idea if it’s the only one you have.** Sahip olduğunuz tek fikir buysa, hiçbir şey bir fikirden daha tehlikeli değildir.

Geleceği tahmin etmek imkansızdır ancak gelecek kaçınılmazdır. Bazı şeyler, bak geliyorum der gibi gelirken bazen de bir anda gelir ve ne olduğunu anlayamayız. Bu yüzden elimizden geldiğince, aslında tedbir alarak yaşamalıyız hayatı, değil mi? Aslında bu davranış, bizim mesleğimiz de kod hayatımızda da geçerli bir durum.

Bir proje düşünün ve bu proje X veri tabanı ile çalışma sergileniyor olsun. Başka bir yerde Y veri tabanı ile aşağı yukarı aynı veri kadar ile farklı bir projede gerçekleşiyor olsun. Y veri tabanı daha hızlı sergileniyor olsun. Bu durumda sistemi değiştirmen ve hızlı adapte olabilen bir sistem kurman gerekiyor. İşte bu durumda 10. Konu ile özdeşleşen bir konunun içerisindeyiz.

Kod yapısı bloklar halinde olmalı ve esnek bir yapıya sahip olmalıdır. Esnek yapıdan kasıt hızlı değiştirilebilir, tersine işlenebilir gibi unsurlardır.

### Topic 12 - Tracer Bullets

Pragmatik programmer olma yolculuğunda bir başka önemli başlık, kodların gözden geçirilme kısmıdır ve kodları yeniden kullanabilir yapmak üzerinedir. Buna kitapta tracer code diyor yazar. Yani iz bırakan kod anlamında. Peki tam manasıyla ne demek bu iz bırakan kod?

Yazılan kod tek kullanımlık değil, tekrar tekrar kullanılabilirdir. Aslında bu konuya Flutter'dan örnek vermek yerinde olacaktır. Flutter'da her şey Widget'lardan oluşuyor doğru. Ancak özelleştirilmiş bir Widget kullanacaksak bunu ayrı bir yerde yazar ve tutardık. Ne zaman kullanmamız gerekiyorsa ona işlevsellik kazandırır ve biryerde hızlıca çağırabilirdik. Özelleştirilmiş Widget'ı tekrar tekrar yazmak yerine hem kodları parçalamaya hem de okunabilirliği artırmaya yönelik bir anlam kazandırmaya çalışırdık. İşte bu işleme bir iz bırakma olayı diyoruz ve gerçekten yerinde bir konu.

Tabi bu sadece basit bir buton örneği diyebiliriz. Tracer kodu daha geniş manada düşünebiliriz. Mesela bir onboarding sayfası diyelim. Onboard sayfası her proje için farklıdır ama özelleştirilebilir tasarlanırsa ve bir kenera konulursa ne zaman istenilip çıkarılmak isteniyorsa çıkarılıp konulabilir.

Bunun çok fazla avantajı var

* Kullanıcı daha performanslı görür projeyi
* Geliştiriciler daha fazla katkıda bulunmaya çalışır.
* Test edilen kod sayısı azalmış olur
* Tracer kod ile, gösterilecek her zaman bir şeyin olur
* Geliştirmek için daha iyi hissedersin kendini

Birde bu kavramı prototiple karıştırmamak lazım. Prototip adı üstünde prototip 🙂 tek kullanımlık kod demek. Proje çıkmadan denemek demek. Tracer code, pasif durumda kod denilebilir. Yeri geldiğinde en sağlam yerinden aktif edilecek kod demek. Zayıf ama zamanı geldiğinde aslan, kaplan olan kod demek.

### Topic 13 - Prototypes and Post-it Notes

Prototip, her üretici firma için olmazsa olmaz kavramıdır. Prototip sayesinde testler yapılır, sonuçlar değerlendirilir, durumlar karşılaştırılır. Peki yazılımda prototip ne anlamlar kazandırır?

* Mimari yapı
* Mevcut sistemde yeni işlevsellikler
* Harici verilerin yapısı ve işlevselliği
* 3. partiler
* performanssal sorunlar
* kullanıcı arayüzü tasarımı

Prototipte peki neleri görmezden gelmeliyiz?

* Dummmy veriler kullanılabilir. Real veri tabanına gerek yok.
* Bütün işlevselliklere gerek yok. Bir parça olsa kafi
* Burada amaç hata bulmak. Kusursuz olmaya gerek yok
* Prototipte amaç testtir. Yorum ve dökman oluştyrmaya çok fazla gerek yok. Ama prototip sonucunda tonlarca belge üretebilirsiniz.

12. konunun sonunda tracer kod ile karşılaştırmıştım. Prototip kodun kullanılma amacı, amacından sapmadan kullanılmalıdır. Prototip kod tek seferlik kullanılan bir koddur. Projede tekrar kullanılma durumu olmamalıdır. Hatalara sebebiyet verebilir, açıklıklara sebebiyet verebilir.

### Topic 14 - Domain Languages

Ludwig Wittgenstein - ***The limits of language are the limits of one’s world.*** Dilin sınırları kişinin dünyasından sınırlıdır.

Müşteriye bir hizmet sunarken bunun açıklamalarını olabildiğince yapmak gerekir.

Rota işlemleri varsa, bunlar detaylı olarak belirtilmeli

yaml dosyasında kullanılan dosyalar belirtilmeli.

Dilin içerisinde eğer yoksa JSON, YAML, CSV gibi dosyalar harici olarak ekleyin ve orada projenizi niteleyin. Orayı bir kimlik olarak düşünün. Zamanınızı çalsa da bu size ileri zamanlarda büyük kolaylık sağlayacak. Bu dosyalara Flutter'dan aşina olmak güzel bir şey benim için. Orada bu dosyalar dilin kendisinde var zaten.

### Topic 15 - Estimating

Pragmatik programmer bir projeye başlamadan önce ekibiyle birlikte projenin tahmin edilebilir türlerini hesaplayarak projeye başlaması gerekmektedir. Bu proje kapsamında projenin ne zaman biteceğini öngörmeli ve ona göre hazırlıklar yapmalıdır.

Projeyi yürütürken bir model oluştur ve o model üzerinden planlar yaparak tahminler yürütmek daha mantıklıdır. 

Burada parametreleri doğru vermek tanımlamada önemlidir. Bu adımda tahmin yeteneğini artırmak mümkünleşiyor.

Tahminleri kaydetmek ve notlar almak, bundan sonraki tahminler için önemli bir kaynak olmaktadır.

Bir ekip içerisinde çalışırken, hangi ekip üyesinin neler yaşadığını normal günlük hayatta bilmeyiz. Hangi ekip üyesinin hangi işi daha hızlı ve daha efektif yapacağını kestirmek gerekmektedir.

Bu konu gerçekten hafife alınacak bir konu değildir. Burada görev veren kişinin biraz oturup, bir kahve yudumlayarak dikkatli bir şekilde düşünmelidir. Bu durumu en iyi gözlemlediğim ortam, daha önce çalıştığım bir şirkette yaşadığım bir polemikti. Bir görev verilmişti ve ben orada daha önce hiçbir işlem yapmamıştım. O teknolojide bir kod bile yazmamıştım. Talep geldi, acil yapman lazım denildi ve hiçbir şey yapamamıştım. Tüm gün bilgisayar ekranına baka kalmıştım. Onun yerine benim görevimi bir başkasına vermek en mantıklı hamle olacaktı ama görevi veren kişi bunu anlamıyordu ve sonuç olarak bir günüm çöp olmuştu.


## Chapter 3

Her çalışan bazı alet edavatlarla çalışır. Bu onların gereksinimleridir. Onlar olmadan o işi yapamazlar. Mesela bir cerrahı düşünecek olursak, onun kullandığı tıbbi dikiş malzemeleri, tıbbi teknolojik aletler; onlar için bilimum önemli aletlerdir.

Bir programcı içinde bu tür gereksinimler söz konusudur. Kullandığımız bir bilgisayardan, kod yazdığım editöre (IDE)'ye kadar her şey bizim göz önümüzdedir ve bizi işimizi yaparken sonuna kadar etkileyen faktörleri içerisinde barındırmaktadır. Şimdi konu konu bunları işlemeye başlayalım.

### Topic 16 - The Power of Plain Text

Bir programcının gücü, dizaynda, gününsonunda ortaya çıkan uygulamada, testlerde ve döküman sayfalarında gizlidir.

Yazılan metnin gücü nedir diye sorulduğunda çıkan 3 madde cevap bulunmaktadır. Bunlar:

* Eskimeye karşı sigorta
* mevcut araçları kullanmaya yönelik
* kolay test edilebilirlik

Burada mesela dışarıdan birisi projeye dahil olduğunda, o proje kapsamında, projeye çok daha hızlı adapte olunabilirlğini göstermektedir.

Mesela bir algoritma yazacaksınız ve bu algoritma Palindrom kelimeleri, cümleleri vs. test edebiliyor olsun. Bu durumda, eğer mevcut bir algoritma varsa o algoritmayı kullanmak en mantıklısıdır. Tekrar tekrar bir şeyi kullanmak yanlıştır. İşte burada bu metinlerin gücünü göstermektedir. Bu geliştiriciye daha fazla imkan tanımaktadır. Düşünmesi gerektiği yerler farklı pencerelerdir. Daha fazla yaratıcılıkla uğraşabilir, burada vaktini sömüren, ırgat mantığı yoktur.

Bu tarz metinlerin en büyük gücü ise, programcılar arasında ortak bir dilin kullanılıyor olmasıdır.

### Topic 17 - Shell Games

Bir futbolcu, sahaya çıkarken sahada performanslı bir oyun sergilemedir. Bu doğru ancak sahaya çıkarken kendini mutlu eden bir hal ile çıkarsa bunu daha iyi yapabilir. Çok uzaklarda aramaya gerek yok, mutluluğu 🤓 Mesela giydiği kramponun rengi, deseni onu iyi hissettirmesine neden olabilir.

Hatta CSGO da iyi bir maç oynamak için, güzel bir bıçak olsa elimizde mesela Butterfly gibi (şimdi fiyatlar uçtu gitti ama olsun örnek bu) oynarken daha bir şevkle oynatıyor insanı. Oysaki bu bıçağın hiçbir etkisi yok oyun oynamada.

İşte programcılar için bu durum söz konusu. Burada kitabın bahsettiği asıl nokta şu: GUI bir kullanıcı için çok faydalı bir şey. Ancak bir geliştirici için insanı körelten bir şey. Biraz elimizi kirletmeli ve kodlarla yönetim yapmalıyız, diyor.

Terminal ekranı da pek sıkıcı be! İşte onu biraz güzelleştirelim diyor.

* Renk temaları ile, keyfine göre ayarlamalar yapabilirsin.
* Prompt ekranında, yani o kod yazılan siyah ekran var ya, özelleştirmeler yapmak, gereksiz şeyleri açmadan kod yazabilmek
* Kodların kısaltmalarını oluşturmak. Basit tags. Örneğin:

``` alias apt-up='sudo apt-get update && sudo apt-get upgrade'```

### Topic 18 - Power Editing

Bir şeyi sürekli tekrarlayıp tecrübe kazanan bir insan, o şeyi çok kısa sürede bitirebilir. Bizim de pragmatic programmer olma amaçlarımızdan birisi, bu akıcılığı kazandırıp bazı şeyleri tekrarlayarak rahata ermemiz. Bunun için birden fazla editor kullanmamız da ya da kullanmamamızda bir sıkıntı yok sadece neyin nasıl olduğunu bilelim yeter.

Mesela örnek verelim. XCode da option tuşuna basarak imleci birden fazla noktada çalıştırabilirsiniz. Bunun inanılmaz büyük bir artısı vardır. Ya da yine XCode da control ve I tuşuna basarsanız Code Formatting yapar. Bunun da etkisi inanılmazdır. Bu tip kolaylıkları keşfederek daha hızlı kod yazabilirsiniz.

### Topic 19 - Version Control

George Santayana - ***Progress, far from consisting in change, depends on retentiveness. Those who cannot remember the past are condemned to repeat it.*** İlerleme, değişimden çok uzak, kalıcılığa bağlıdır. Geçmişi hatırlayamayanlar onu tekrarlamaya mahkumdur.

VCS yani **Version Control System** bir yazılımcı için en önemli araçlardan biridir. Olmazsa olmazımızdır. Hangi yazalım alanı olursa olsun kullanması gereken bir araçtır. Bir zorunluluktur. Kullanılmama gibi ihtimali bile yoktur. Bu kadar önemli bir şey tam olarak nedir? Mesela Git kavramı. Git kavramını herkes duymuştur. İşte Versiyon kontrol sistemimiz mesela budur. Bunun gibi CVS, SVN gibi onlarca var. Ancak en meşhur olan kavram Git dir.

Git üzerinden gidersek eğer, giti yönetebileceğiniz siteler bulunmaktadır. Github, Bitbucket, Gitlab gibi.

Peki ne işe yarar bu? En büyük avantajı yazdığınız kodlar bir yerde saklanmaktadır. Mesela bir projeye geliştirmeye başladınız. Projenizi sürekli pcde tutmanıza gerek yok at Git'e at orda dursun. Arkadaşlarınızla beraber proje mi geliştiriyorsunuz? Github kullanmak **ZORUNLU** Yoksa ne yapacaksınız? Whatsapp da birbirinize tek tek zip halinde projeyi mi atacaksınız? onun yerine 2 satır kodla Git'e atıp çekmek dururken. Hatta Git tool'ları sayesinde 1 tuşla her şeyi yapabiliyorsunuz. Mesela Sourcetree gibi ya da Github kendi tool'u bulunmakta, o da güzel.

Bu konuyu uzun uzadıya yazmak mümkün ancak ben blog sayfamda bahsetmiştim. Onun linki için [tıklayınız.] (https://ozturkomerfaruk.com/git-komutlari-ve-kullanimi-her-sey/)

### Topic 20 - Debugging

Debug etmek deyimi, gerçekten yazılımcıların günlük hayatta kullandığı belki en sık deyimdir. Sürekli çıkan hataları çözme konusunda belki de en gerçekçi yöntemdir. Ayrıca benim için IDE'yi IDE yapan Debug ederken verilen ayrıntıların güzelliğidir. Her IDE maalesef aynı şekilde sonuçları vermiyor.

Şimdi adım adım Debug etmek nasıl yapılıyor, bir örnek üzerinden gideceğiz.

1. Android Stuido üzerinde Flutter'da bir proje geliştiriyoruz. API'dan veri çekeceğiz ve ekrana bastıracağız. Ancak veriler gelmiyor, sorun ne olabilir diyoruz?
2. Ekrana bastırdığımız UI tool'una debug point'i koyuyoruz. O tool'a ulaşan controller'a koyuyoruz. Controller'a giden API fetch ettiğimiz url'ye koyuyoruz.
3. Sırayla Debugları çalıştıracağız. İlk başta UIButton'un çalıştığını görüyoruz ancak veri gelmiyor. Controller'a da veri gelmiyor. Öyleyse API'da ya bir sıkıntı var ya da verileri doğru çekemiyoruz diyoruz.
4. API da gelen url'yi kontrol ederken bakıyoruz. Status 200 mü dönmüş. Hayırsa sorun ya url yi yanlış yazdık ya o tarafta bir sıkıntı var. Bu 200 vs. nedir diye soracak olursanız. [Şuraya](https://ozturkomerfaruk.com/http-durum-kodlari-nelerdir/) tıklayabilirsiniz.
5. Sonra adım adım çözüm yapmaya başlıyoruz.

Ayrıca API'da gelen statuyu kontrol ederken gelen verinin neler getirdiğini de detaylıca görebilirsiniz. Çok büyük bir projede çalışıyorsanız, gelen verinin illa bir yerlere bastırarak görmek zorunda değilsiniz. Mesela Debug ettiniz ve kocaman bir JSON dosyası çıktı. Bunun modelini oluşturacaksınız. Tek tek oluşturmaya ne gerek var. Debug da JSON dosyasını kopyala, al örneğin JSON to Dart yaz internete. İnternette çıkan Model oluşturma sitelerinden birini gir dönüştür kopyala projeye yapıştır düzenlemelerini yap.

Debug da her detayı aslında görmek mümkün. Tabi dilden dile, framework'ten framework'e, editörden editöre çok şey değişse de Debug etmek her alan için söz konusu. Bu alanda yazılan yazılar, çıkan notlar vs. hep söz olup uçup gidiyor. Çalıştığınız editörün ve dilin tüm Debug özelliklerini keşfedin

### Topic 21 - Text Manipulation

[The Practice of Programming](https://www.amazon.com/Practice-Programming-Addison-Wesley-Professional-Computing/dp/020161586X) adlı kitapta yazar bir projeyi 5 farklı dilde yazmış. Perl ile metinleri değiştirebilir, programlarla etkileşime girebilir, ağlar üzerinden konuşabilir, web sayfalarını yönetebilir, keyfi hassas aritmetik yapabilir ve Snoopy küfürüne benzeyen programlar yazabilirsiniz.

GNU/Linux üzerinde (Buraya macOS kullanıcıları da dahildir) awk & sed terimleri bulunmaktadır. Bunlar Text yönetiminde önemli kriterlerdir. Göz gezdirmenizi tavsiye ederim.

İlgili makaleye gitmek için [tıklayın.](https://linux-yonetimi.veriteknik.net.tr/gelismis-terminal-komutlari/awk-ve-sed)

### Topic 22 - Engineering Daybooks

Günlük not almak, konuşurken insnaların ağzından notlar çıkarmak, onları bir ders niteliği gibi dinlemek, toplantılarda söylenenleri unutmamak için not almak bize şu avantajları sağlar:

* Bellekten daha güvenilirdir. İnsanlar “Geçen hafta güç kaynağı sorunu için aradığınız şirketin adı neydi?” Diye sorabilir. ve bir sayfa geri çevirebilir ve onlara isim ve numara verebilirsiniz.
* Eldeki görevle hemen alakalı olmayan fikirleri depolamak için bir yer sağlar. Bu şekilde, harika fikrin unutulmayacağını bilerek, yaptığınız şeye konsantre olmaya devam edebilirsiniz.
* Bir tür lastik ördek görevi görür (burada açıklanmıştır). Bir şey yazmak için durduğunuzda, beyniniz neredeyse sanki sanki vites değiştirebilir.
biriyle konuşmak—düşünmek için harika bir fırsat. Bir not almaya başlayabilir ve sonra aniden yaptığınız şeyin, notun konusunun tamamen yanlış olduğunu fark edebilirsiniz.
* Ek bir faydası da var. Arada bir, yıllar önce ne yaptığınıza bakabilirsiniz ve insanları, projeleri, korkunç kıyafetleri ve saç stillerini düşünebilirsiniz.

Ancak bunları yazarak yapın. Not defterleriniz oluşsunuz. Yılların günlükleri olsun.

## Chapter 4 - Pragmatic Paranoia

Valla en çok kendimde gördüğüm kısım sanırsam burası. Kendimi sürekli ben iyi bir yazılımcı değilim diye söyleyip duruyorum. Çalışıyorum ama çalışmak yetmiyor. İnsanlar bana nazaran çok iyi algoritmalar yazıyor. İnsanlar çok hızlı ve bu bende biraz yok. Bakalım bu kitap bu kısmı nasıl avantaja dönüştüreceğimi anlatıyor. Heyecanla, büyük bir ilgiyle okumaya başlıyorum.

### Topic 23 - Design by Contract

Ralph Waldo Emerson - ***Nothing astonishes men so much as common sense and plain dealing.*** Hiçbir şey insanları sağduyu ve sade davranış kadar şaşırtamaz.

Bir işe başlamadan önce bir sözleşme imzalarız. Bu sözleşme kapsamında ne iş yapacağımız, karşılığında ne alacağımız ya da ek ikramiye, avantaj vs. ne varsa her şey bu sözleşme kapsamında bize belirtilir ve biz onlara tabi olarak yaşamaya başlarız. Aslında bu durum yazılım için de söz konusu. Kod yazmaya başlamadan önce neyin ne olduğunu bilmemiz gerekir. Bunu şu maddelerle açıklamak mümkün:

* Ön koşullar. Yani bir yazılımda koda başlamadan ön koşulları kestirmek ve örneği front ende backend den veriyi doğru bir şekilde getirmek yazılımcının görevidir.
* Son koşullar. Yine aynı örnekte, yazılımcı veriyi getirirken sonsuz bir döngüye girmesini izin vermez.
* değişmezler. (invariants)

Arayan tarafından rutinin tüm ön koşulları karşılanırsa, rutin tamamlandığında tüm son koşulların ve değişmezlerin doğru olacağını garanti eder. Taraflardan herhangi biri sözleşmenin şartlarına uymazsa, (daha önce üzerinde anlaşmaya varılmış olan) bir çözüme başvurulur - belki bir istisna ortaya çıkar veya program sonlandırılır. Bu duruma da DBC denilmektedir.

DBC sizi düşünmeye zorlar. Size şu avantajları sağlar:

* DBC herhangi bir kurulum veya ek olay gerektirmez
* DBC, her durumda başarısızlığın başarısı için parametreleri tanımlar, oysa test bir seferde yalnızca belirli bir durumu hedefleyebilir
* TDD ve diğer testler, yalnızca derleme döngüsü içinde "test zamanında" gerçekleşir. Ancak DBC ve iddialar sonsuza kadar sürer: tasarım, geliştirme, dağıtım ve bakım sırasında
* TDD, genel arayüzü kontrol etmek için daha fazla kara kutu stilini test eden kod içindeki dahili değişmezleri kontrol etmeye odaklanmaz
* DBC, kimsenin onaylamaması durumunda herkesin doğrulaması gereken savunmacı programlamadan daha verimlidir (ve DRY-er).

Kodu yazmadan önce, giriş etki alanı aralığının ne olduğunu, sınır koşullarının neler olduğunu ve rutinin ne vaat ettiğini veya daha da önemlisi neyi sağlamayı vaat etmediğini basitçe sıralamak, daha iyi yazmada büyük bir adımdır.

### Topic 24 - Dead Programs Tell No Lies

Error bir yazılımcının olmazsa olmazıdır. Errorsuz kod yazmak imkansızın imkansızıdır. Her han her şey olabilir. Program patlayabilir neden patladığını anlamazsın ya syntax hatası vardır ya mantıksal bir hatadır ama hatadır sonuçta o. İşte bu konu başlığında biraz daha bu alana değinilecektir

Mesela bazı yazılımcılar try catch içerisinde herbir hatayı önceden kestirip throw ederek hatayı bastırmayı tercih ediyor. Güzel bir örnektir aslında bu çünkü herbir kod un olası hatalarını kestirip eğer hata çıkarsa bastırıp göstermek güzel bir kolaylıktır.

Hatalar çok garip bir dünya ve insana çok şey öğretir. Mesela bu Vakıfbank iOS bootcampin ilk ödevi basit bir palindrom sorusuydu ancak bu soruda ben hep kelimeler çalışıyor mu çalışmıyor mu diye bakıyordum meğersem cümleler de oluyormuş. Buda yetmiyormuş gibi arada geçen virgül, nokta, ünlem gibi noktalama işareletinin de göz ardı edilmesi gerekiyormuş. Okunuşları baştan sona, sondan başa aynı olsa yetiyormuş. Ben bilmiyordum mesela. Palindrom da crash etti ilk başta ama düzenleyince çok mutlu oldum gibi.

### Topic 25 - Assertive Programming 

Oscar Wilde - ***There is a luxury in self-reproach. When we blame ourselves we feel no one else has a right to blame us.*** Kendini suçlamada bir lüks vardır. Kendimizi suçladığımızda, kimsenin bizi suçlamaya hakkı olmadığını hissederiz.

Evet, iddalı olmayacaksın 🥹 Zaten iddalı olacak bir konu da yok sadece konrol etmeyi bilmelisin. Mesela API dan veri çekiyorsun ve oluşturduğun modele atacaksın diyelim. Yani gerek yok o modelindekileri Option bir şekilde kur ve if let, guard let ya da try catch ile sarmala. Belki null gelir belki gelir bilemezsin. Veri tabanına nasıl tutulduğunu bilemezsin. Garantici olmakta fayda var.

Hem Ramiz Karaeski ne demişti: ***Bilemem kardeşş. Portakalı soymadan içinde ne var bilemem.*** 

### Topic 26 - How to Balance Resources

Ursula K.Le Guin - ***To light a candle is to cast a shadow...*** Mum yakmak, gölge düşürmektir...

Kod yazarken, uygulama çıkarırken göz ardı edilen bazı noktalar bulunmaktadır. Memory yönetimi, transactions, threads, network bağlantıları, dosyalar, zamanlamalar gibi. Bunlar pek dikkat edilmez ve sonra uygulama 10 saat sonra açılıyor. Büyük şirketler bunlara öylesine dikkat eder ki, yazılımcıların belki de tek işi budur. Facebook, Youtube gibi devasa şirketlerin çok hızlı bir şekilde açılması başka nasıl mümkün olabilir ki? Youtube hala bana inanılmaz geliyor. Her video 4K belki ama site bir anda açılıyor bir anda video açıp izleyebiliyorum.

Nest Allocations

1. Kaynakları, tahsis ettiğiniz sıranın tersi sırayla tahsis edin. Bu şekilde, bir kaynak diğerine referanslar içeriyorsa kaynakları öksüz bırakmazsınız.
2. Aynı kaynak grubunu kodunuzda farklı yerlere tahsis ederken, onları her zaman aynı sırayla tahsis edin. Bu, kilitlenme olasılığını azaltacaktır. (Eğer süreç A kaynak1 talep ediyorsa ve kaynak2 talep etmek üzereyse, süreç B kaynak2'yi talep etmiş ve kaynak1'i almaya çalışırken, iki süreç sonsuza kadar bekleyecektir.)

Kitapta bu konu aslında baya detaylı değinilmiş ancak ben Swift için yorumlamak istiyorum. Swift dilinin bazı kolaylıkları var. Kitap da mesela Ruby, C gibi dillerden örnekler veriyor ama günlük hayatta o dillerin pek önemi kalmadığı için (benim için hiç yok) Bellek yönetimi konusunda Swiftin kolaylıklarından bahsetmek daha güzel. Nesne tabanın getirdiği bir kolaylık vardır sınıflar oluşturulurken ve sınıfın işi biterken bazı metotlar çalışır. Bunları deinit gibi. Bunlar son derece önemlidir. Kodlar yazılırken veri yapıları ve algoritmalardan yararlanmak gerekir. BigO için önemli etkenlerdir ve çok ciddi yararlar sağlamaktadır. Aynı zamanda uygulama içerisinde sayfaları yönetirken o sayfaların içeriğinde weak, strong gibi kavramlar vardır. Bu kavramlarda weak mesela ihtiyaç duyulduğunda çağrılabilir der. Ya da nesne tabanın getirdiği lazy anahtar kavramı gibi. Aslında bu başlıkları internetten aratmak ve Swift de bellek yönetimi nasıl olmalıdır diye araştırmak en azından bu konu başlığı için daha iyi olduğunu düşünüyorum. Temel noktaları kitap değinmiş ama örnekler pek iç acıcı gelmedi bana.

### Topic 27 - Don't Outrun your Headlights

Lawrence - ***It’s tough to make predictions, especially about the future.*** - Özellikle gelecekle ilgili tahminlerde bulunmak zor.

Gece, zifiri karanlıkta araba sürüyorsunuz ve farlarınızın gördüğü yer kadar araba sürebiliyorsunuz. Ya farlarınızı kapatırsanız ne olur? Gece 120 km/h hızda giderken farlarınızın olmadığını düşünün...

İşte yazılımda da mesele aynı. Görev alırken, bir sorumluluk alırken, bir işe kalkışırken farların gördüğünden ileride olmak anlamsızdır, yorucudur, bıkkınlık vericidir. Pragmatik programcının tek kuralı vardır. Oda küçük adımlar atmak ancak daima atmak. Aşağıdaki maddeler, pragmatik programcının adım adım ilerleme aşamalarıdır.

* Tahmini tamamlanma tarihi
* Gelecekteki bakım veya genişletilebilirlik için bir tasarım planlama
* Kullanıcının gelecekteki ihtiyaçlarını tahmin etme
* Gelecekteki teknoloji kullanılabilirliğini tahmin etme

## Chapter 5 - Bend, or Break

Hayat değişiyor, yazılım dünyası da değişiyor. Kodlar da değişiyor. Adapte olmak ve sürekli güncel durmak şart

### Topic 28 - Decoupling

John Muir - ***When we try to pick out anything by itself, we find it hitched to everything else in the Universe.*** Herhangi bir şeyi kendi başına seçmeye çalıştığımızda, onun evrendeki diğer her şeye bağlı olduğunu görürüz.

Devasa bir projede çalışıyorsunuz diyelim. Projede bazı adımları değiştirmeniz gerekiyor. Burada 4 durumda değişiklik olabilir.

* İlişkisiz modüller veya kütüphaneler arasındaki tuhaf bağımlılıklar.
* Sistemdeki ilgisiz modüller arasında yayılan veya sistemin başka bir yerindeki öğeleri kıran bir modülde "basit" değişiklikler.
* Neyin etkilenebileceğinden emin olmadıkları için kodu değiştirmekten korkan geliştiriciler.
* Kimsenin bir değişiklikten kimin etkileneceğinden emin olmadığı için herkesin katılması gereken toplantılar.

Mesela satış yapan birisine bir hizmet satacaksınız ve satış yapanın dedikleri her şeyi uygulamaya yansıtıyorsunuz diyelim. Ancak alan kişi dedi ki, ben en fazla yüzde 40 indirim uygularım bir ürüne. Haydaaa! Bunu nereye koyayacağız peki bu bilgiyi, bu bilgi çok esnek bir kavram. İndirim oladabilir, olmayada bilir belki 2 sene sonra yuzde 40 dan fazla indirim uygulayacak bilemezsin. Bu sebeple, notlar alınarak, ve geliştiriciler arasında ortak fikir birlikleri ile haraket edilerek gidilmelidir.

**Demeter yasası**

İnsanlar genellikle eşleşmeyle ilgili olarak Demeter Yasası veya LoD denen bir şeyden bahseder. LoD, 80'lerin sonlarında Ian Holland tarafından yazılmış bir dizi yönergedir


Global veriler yazmak unit testleri yazmayı ya güçsüzleştirir ya da etkisiz hale getirir. Ne kadar global veriden uzak tutup, ayrıştırılabilir ve yeniden kod yazmaya müsait kodlar yazarsanız o kadar doğru bir ilkede olmuş olursunuz.

Küresel Veriler Dış Kaynakları İçerir
Herhangi bir değiştirilebilir harici kaynak, global veridir. Uygulamanız bir veritabanı, veri deposu, dosya sistemi, hizmet API'si vb. kullanıyorsa, küreselleşme tuzağına düşme riski vardır. Yine çözüm, bu kaynakları her zaman kontrol ettiğiniz kodun arkasına sardığınızdan emin olmaktır.

Inherit ederken yani miras alırken, bunu kötü kullanmak o kadar kötü sonuçlara sebebiyet verebiliyor ki, buna bilhassa dikkat edilmesi gerekmektedir. Ayrıca değişen bir kodu tekrar değiştirmeye çalışmak hatalara sebebiyet verebilir. O yüzden iyi kurgulanmalıdır.

### Topic 29 - Juggling the Real World

John F. ***Things don't just happen; they are made to happen.*** Olaylar öylece olmaz; onlar gerçekleşmesi için yapılmıştır.

Yazılan uygulamaların dinamik olması, insanlarla etkileşimin olması, dünyaya açılmada daha etkin rolde olacaktır. Peki ama nasıl? Uygulamada göz önünde bulunması gereken maddeler

1. Finite State Machines
2. The Observer Pattern
3. Publish / Subscribe
4. Reactive Programming and Streams

**Finite State Machines**

Durum makinesi, temel olarak olayların nasıl ele alınacağının bir özelliğidir. Biri mevcut durum olan bir dizi durumdan oluşur. Her eyalet için, o eyalet için önemli olan olayları listeleriz. Bu olayların her biri için sistemin yeni mevcut durumunu tanımlarız.

**The Observer Pattern**

Mobil teknolojilerde sık sık kullanılan bir patterndir. Bir gözlemci, tipik olarak çağrılacak bir fonksiyona bir referans ileterek, ilgisini gözlemlenebilir olana kaydeder. Daha sonra, olay meydana geldiğinde, gözlemlenebilir, kendi gözlemci listesini yineler ve her birinin kendisinden geçen işlevi çağırır. Olay, o çağrıya parametre olarak verilir.

**Publish / Subscribe**

Bunlar kanallar aracılığıyla birbirine bağlanır. Kanallar ayrı bir kod gövdesinde uygulanır: bazen bir kütüphane, bazen bir süreç ve bazen de dağıtılmış bir altyapı. Tüm bu uygulama ayrıntıları kodunuzdan gizlenmiştir.
Her kanalın bir adı vardır. Aboneler, bu adlandırılmış kanallardan bir veya daha fazlasına ilgi gösterir ve yayıncılar bunlara etkinlik yazar. Gözlemci modelinden farklı olarak, yayıncı ve abone arasındaki iletişim kodunuzun dışında gerçekleştirilir ve potansiyel olarak eşzamansızdır.

Ancak her güzel şey uygulanmaz. Eğer çok fazla pub/sub varsa bir projede onda kontrol etmek zorlaşır neyin ne olduğunu bilmek güçleşir.

**Reactive Programming and Streams**

çok iyi bildiğimiz diğer tüm veri-ish şeyleri manipüle edebilir, birleştirebilir, filtreleyebilir ve yapabiliriz. Hatta etkinlik akışlarını ve düzenli koleksiyonları birleştirebiliriz. Akışlar eşzamansız olabilir; bu, kodunuz, olaylara geldiklerinde yanıt verme fırsatına sahip olur.

### Topic 30 - Transforming Programming

W. Edwards Deming - ***If you can't describe what you are doing as a process, you don't know what you're doing.*** Ne yaptığınızı bir süreç olarak tanımlayamıyorsanız, ne yaptığınızı bilmiyorsunuz demektir.

Bir programı ilk başta, programın genel olarak işlevleri belirlenmelidir. Daha sonra, programın girdileri, çıktıları belirlenmelidir. Daha sonra belli başlı işlemlerden geçtikten sonra:

bir kod → veri → kod → veri dizisidir.... Veriler, bir sınıf tanımında olduğu gibi artık belirli bir işlev grubuna bağlı olmuyor. Bunun yerine, girdilerini çıktılarına dönüştürürken uygulamamızın gelişen ilerlemesini temsil etmekte özgürdür. Bu, eşleşmeyi büyük ölçüde azaltabileceğimiz anlamına gelir: bir işlev, parametrelerinin başka bir işlevin çıktısıyla eşleştiği her yerde kullanılabilir (ve yeniden kullanılabilir).

Evet, hala bir dereceye kadar bağlantı var, ancak deneyimlerimize göre OO tarzı komuta ve kontrolden daha yönetilebilir. Ayrıca, tür denetimi olan bir dil kullanıyorsanız, uyumsuz iki şeyi bağlamaya çalıştığınızda derleme zamanı uyarıları alırsınız.

Ancak bu durumda Error'lar çıkması muhtemel olduğu için Error handling de yapmak gerekiyor.

Bu konu eğer detaylı bir şekilde incelenip, uygulanmaya başlarsa kod çok daha temiz, çok daha anlaşılı olacaktır.

### Topic 31 - Inheriance Tax

Joe Armstrong - ***You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.*** Muz istedin ama elinde muzu ve tüm ormanı tutan bir goril vardı.

Adından da anlaşılacağı üzere kalıtım, atadan oğula bırakılandır. Nesneye yönelik programlamada ifade edersek: kalıtım, bir sınıftan(üst sınıf/super class) başka bir sınıfa miras bırakılandır. Java programlamada ise bir oğulun yalnızca bir ata sınıfı olabilir.

Aynı şekilde inheritance gibi Delegation da bulunmaktadır. Bir sınıfın yapması gereken bir işi başka bir sınıfa devretmesi gibi. Delegation Pattern denilmektedir hatta. Daha sonrasında Mixins, Traits, Categories ve Protocol Extensions gibi kavramlarda bulunmaktadır. Bunların da bazıları Swift dilinde kullanılmaktadır.

### Topic 32 - Configuration

Benjamin Franklin - ***Let all your things have their places; let each part of your business have its time.*** Her şeyin yerini alsın; işinizin her bir parçasının kendi zamanı olmasına izin verin.

Kodlar değiştirilmek zorunda kalabilir bunun için parametrize etmek her şeyi çok önemlidir. Kitapta daha çok bunu yapmak için verileri JSON formatında tutmayı vs. diyor ancak günümüzde zaten mobil uygulama geliştirmede API verileri yüzde 99.99 JSON formatında yazıldığı için, bizim zorunlu alışkanlığımız oluyor. O yüzden sıkıntı yok, devam.

## Chapter 6 - Concurrency

Thread kavramına giriyoruz. Haydi Bismillah

### Topic 33 - Breaking Temporal Coupling

Göz ardı edilmemesi gereken bir olaydır. Projenin geçici harcadığı zamanlar tespit edilmelidir.

En güzel yollardan biri aktivite diagramı oluşturmaktır. Nedir bu diagram? Bir projenin akış şemasıdır. Hangi sayfadan hangi sayfaya gittiğini gösteren, işlevlerini gösteren geniş çaplı bir şeydir.

Bir veritabanını sorgulamak, harici bir hizmete erişmek, kullanıcı girdisini beklemek: tüm bunlar normalde programımızı tamamlanana kadar oyalar. Bu aktivite diagramları sayesinde nerede ne var sorularının cevapları ile CPU'yu yormayı en aza indirgeme hedeflenmektedir.

Peki bunu hızlı ve güvenilir nasıl yapacapız?

### Topic 34 - Shared State Is Incorrect State

En sevdiğiniz lokantada olduğunuzu düşünün. Ana yemeğinizi bitirdiniz ve garsona elmalı turta kaldı mı diye sordunuz. Garson arka tarafa baktı, vitrinde bir parça gördü ve size evet dedi. Siparişinizi verdiniz ve lezzetli turtanızın servis edilmesi için sabırsızlanıyorsunuz.

Bu arada, restoranın diğer tarafında başka bir müşteri, garsona aynı soruyu sordu. O garson da vitrine baktı ve bir parça elmalı turta olduğunu gördü. Müşteri siparişini verdi ve servisini beklemeye başladı. Bu durumda günün sonunda maalesef müşterilerden biri hayal kırıklığına uğrayacaktır.

İlk garson, mevcut pasta sayısını alır ve bunun bir olduğunu görür. Pastayı müşteriye getireceğini söyler. Ama bu noktada ikinci garson başka bir masada ayrıca pasta sayısının bir olduğunu görür ve müşterisine aynı sözü verir. İkisinden biri daha sonra pastanın son parçasını alır ve diğer garson bir tür hata durumuna girer.

Buradaki sorun, iki işlemcinin aynı belleğe yazabilmesi değildir. Sorun şu ki, hiçbir işlemci o belleğe bakışının tutarlı olduğunu garanti edemez. Bir garson display_case.pie_count()’u çalıştırdığında, vitrindeki değeri kendi hafızalarına kopyalar. Vitrindeki değer değişirse, hafızada tuttuğu değerin artık doğruyu göstermediği anlaşılır.

Bunun nedeni, pasta sayısının getirilmesi ve ardından güncellenmesinin atomik bir işlem olmamasıdır: değer ortada değişebilir. Peki bunu nasıl atomikleştiririz?
Bir semafor, aynı anda yalnızca bir kişinin sahip olabileceği bir şeydir. Bir semafor oluşturabilir ve ardından başka bir kaynağa erişimi kontrol etmek için kullanabilirsiniz. Örneğimizde, pasta durumuna erişimi kontrol etmek için bir semafor oluşturabilir ve pasta durumu içeriğini güncellemek isteyen herkesin bunu ancak o semaforu elinde tutuyorsa yapabileceği kuralını benimseriz.

Lokantanın pasta sorununu fiziksel bir semaforla çözmeye karar verdiğini varsayalım. Pasta kutusuna plastik bir Leprikon yerleştirirler. Herhangi bir garson bir turta satmadan önce, Leprikon’u ellerinde tutuyor olmalıdır. Siparişleri tamamlandıktan sonra bir sonraki siparişe aracılık etmeye hazır olan Leprikon’u turtaların hazinesini koruyan yerine iade edebilirler.

Her iki garsonun da aynı anda kodu çalıştırdığını varsayalım. İkisi de semaforu kilitlemeye çalışır, ancak yalnızca biri başarılı olur. Semaforu alan normal olarak çalışmaya devam eder. Semaforu almayan, semafor hazır olana kadar askıya alınır (garson bekler…). İlk garson siparişi tamamladığında semaforu açar ve ikinci garson çalışmaya devam eder. Artık vitrinde pasta olmadığını görür ve müşteriden özür diler.

Angie - ***Without writers, stories would not be written, Without actors, stories could not be brought to life.*** Yazarlar olmadan hikayeler yazılmaz, Oyuncular olmadan hikayeler hayata geçirilemezdi.

Aktörler ve süreçler, paylaşılan belleğe erişimi senkronize etme yükü olmadan eşzamanlılığı uygulamanın ilginç yollarını sunar. Ancak aktör ne süreç ne?

Bir süreç, genellikle eşzamanlılığı kolaylaştırmak için işletim sistemi tarafından uygulanan daha genel amaçlı bir sanal işlemcidir.

Aktör: Kendi yerel durumuna sahip bağımsız bir sanal işlemcidir. Aktörler eşzamanlı eşzamansız olarak çalışır hiçbir şey paylaşmazlar.

Bu bileşen seti, tek bir işlemcide, birden çok çekirdekte veya birden çok ağ bağlantılı makinede eşit derecede iyi çalışabilir.

### Topic 36 - Blackboards

Daniel - ***The writing is on the wall...*** Yazı duvarın üzerinde...

Dedektifleri düşünün bir odada tartışıyorlar. Bir tane kara tahta var ve başlığı kaza ya da cinayet yazıyor. Dedektifleri kara tahtada şu ifadeleri yazmışlar

- Dedektifler, diğer dedektiflerin bunu sorgulayıp sorgulamadığını önemsemeden sadece tahtayı okuyorlar.
- Aynı projede çalışan dedektiflerin hepsi aynı alanda uzman olmak zorunda değiller.
- Dedektiflerin hepsi aynı saatlerde çalışmak zorunda değil.
- Tahtada her bir halt olabilir. Kısıtlama yok. Ne kadar delil o kadar köfte.

İşte bu durum dedektifleri aktör yapmaktadır. Birbirinden bağımsızlar.

Mimariye aktör ve/veya karatahta ve/veya mikro hizmet yaklaşımı, uygulamalarınızdaki tüm potansiyel eşzamanlılık sorunlarını ortadan kaldırır. Ancak bu faydanın bir bedeli vardır. Eylemlerin çoğu dolaylı olduğu için bu yaklaşımlar hakkında akıl yürütmek daha zordur. Özellikle havuz sizin için kodu ve belgeleri oluşturabiliyorsa, mesaj biçimleri ve/veya API'ler için merkezi bir havuz tutmanın yardımcı olduğunu göreceksiniz. Sistemde ilerledikçe mesajları ve gerçekleri takip edebilmek için iyi araçlara da ihtiyacınız olacak. (Yararlı bir teknik, belirli bir iş işlevi başlatıldığında benzersiz bir izleme kimliği eklemek ve ardından bunu ilgili tüm aktörlere yaymaktır. Daha sonra, günlük dosyalarından ne olduğunu yeniden oluşturabileceksiniz.)

Daha fazla hareketli parça olduğundan, bu tür sistemlerin konuşlandırılması ve yönetilmesi daha zahmetli olabilir. Bir dereceye kadar bu, sistemin daha ayrıntılı olması ve tüm sistem yerine tek tek aktörlerin değiştirilmesiyle güncellenebilmesi gerçeğiyle dengelenir.

## Chapter 7 - While You Are Coding

Bir proje var aklınızda ve mobil uygulama çıkartacaksınız diyelim. İnternette araştırma yapıyorsunuz ve görüyorsunuz ki, kod yazmak gerekiyor. Swift, Kotlin, Flutter, React Native vs. öğrenmek zorundasınız. Ama sonra birde görüyorsunuz ki, ee abi sıfır kod yazarak, sürükle bırak yaparak da uygulama çıkartılabiliyormuş. Bu mobil yazılımcılar salak mı, niye bunla uğraşmıyorlar da vakitlerini mal gibi harcıyorlar diyorsunuz diyelim. Demezsiniz de, diyorsunuz diyelim. İşte bu bölüm bunun cevabını size anlatıyor çünkü sevgili arkadaş bu soruyu sorup işin işine girdiğinde görecek ki, o kadar kolay olmuyormuş bu işler. Kodlar static değerler değilmiş her an değişebilecek dinamik değerlermiş. Kodlar düzenli yazılması gereken şeylermiş. Başıboş yazılmaması gereken şeylermiş. O sıfır kod dediği yerde, bütün kodlar hazır olarak tutulup veriliyor. Üzerinde oynama etme yapılmıyor hiç. Olmaz öyle 🥸

### Topic 37 -  Listen to Your Lizard Brain

Gavin de Becker - ***Only human beings can look directly at something, have all the information they need to make an accurate prediction, perhaps even momentarily make the accurate prediction, and then say that it isn’t so.*** Sadece insan bir şeye doğrudan bakabilir, doğru bir tahminde bulunmak için ihtiyaç duyduğu tüm bilgilere sahip olabilir, hatta belki bir an için doğru tahminde bulunabilir ve sonra öyle olmadığını söyleyebilir.
