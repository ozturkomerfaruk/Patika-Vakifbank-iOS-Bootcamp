Bu kitapta ki konu başlıklarını özetler nitelikte, kendimden cümlelerle yazmaya çalıştım. Kitabı okumanızı muhakkak tavsiye ediyorum.

# Pragmatic Programmer

Pragmatik Bir Programcı Ne Yapar?

Her yazılımcı kendi stilini bir gün bulacak ve bunlar; hobiler, kıyaflet kadar keskin olacak. Ancak, pragmatik bir programcıysanız şu özelliklere sahip olmalısınız:

1. Hızlı adapte olabilme
2. Meraklı
3. Kritik noktaları düşünebilme
4. Gerçekçi
5. Her işte usta olabilme

Sadece bir konuda uzman değil, yeni bir konuda da rahatça uzmanlaşabilmeli ve hızlı adapte olabilmesi lazım bir pragmatik programcının. Yeni bir şeyler öğrenme konusunda her zaman meraklı olabilmeli ve herkesin aklına gelmeyecek şeyleri de düşünebilmeli ve araştırabilmelidir. Son derece gerçekçi olmalıdır. Bir proje ne zaman biter ya da ne gibi zorluklarla yönetilebilir.

1. Yaptığımız işi önemsemek
2. Yaptığımız işi düşünmek

Önemseyeceğiz ki, sadece kod yazan bir yazılımcı olmak istemiyoruz. İstiyoruz ki daha iyi bir yazılımcı olabilmek. Öyleyse yaptığımız işleri düşüneceğiz. Düşüneceğiz ki, daha iyi bir yazılımcı olalım. Bu kitapta düşünmeyi öğreneceğiz.

## Chapter 1 - A Pragmatic Philosophy

### Topic 1. It's Your Life

Bruce Lee - ***I'm not in this world to live up to your expectations and you're not in this world to live up to mine*** Ben bu dünyaya senin beklentilerini karşılamak için gelmedim. Sen de benimkilerini karşılamak için gelmedin.

Hayatınızı düşünün. Eleştirdiğiniz şeyleri düşünün. Ne kadarı sizin üzerinizde etkili, ne kadarını değiştirebilir ne kadarını değiştiremezsiniz. Eğer hayattan zevk almak istiyorsanız, sizi üzen şeyleri terk etmelisiniz. Yazılım sektörü çok fazla imkan sunarken, sizin imkanızı kısıtlayan şeyleri engellemelisiniz. Sizi üzen şeyleri hayattan çıkarmalısınız. Risk almalısınız ve kararınızı sonuna kadar desteklemelisiniz. Evet hayat bazen çok acı verici oluyor ancak ayağa kalkabilmeli ve savaşmalısınız.

Sadece şunu unutmayın. Ne konuda acı çektiğinize dikkat edin. Acı çektiğiniz şey, sizi güçlendiren bir şey mi, yoksa boşa mı kürek çekiyorsunuz.

### Topic 2. The Cat Ate My Source Code

J.B. Bossuet, Politics from Holy Writ, 1709 - ***The greatest of all weaknesses is the fear appearing weak*** Zayıflıkların en büyüğü, zayıf görünme korkusudur.

Sorumluluk bilinci birçok şeyin üstündedir. Eğer bir göreviniz varsa ve bunu yapacağım dediyseniz onu yapmakla mükellefsiniz. Zorluklar olabilir ancak buna uygun bir yol haritası çizilmeli ve son sürat hedefe doğru koşulmalıdır.

Eğer ortada bir hata varsa, bir kötü durum söz konusuysa üzerinize sorumluluk almayı bilin. Başkasını eleştirmek, başkası üzerinden prim yaparak haklı çıkmaya çalışmak son derece yanlış şeyler. Eğer ortada büyük bir iş söz konusuysa üzerine düşen sorumluklar ile ortaya çıkıp insanlara bir şeyler anlatmaya çalış. Ben işin bu tarafını tutarım de ama asla bir köşeye geçip yan gelip yatma.

Bilmiyorum demek işin en kolay yanı. Pragramatic Programmer bilmiyorum kelimesinin yanında *ama öğreneceğim* der ve devamında profosyonel bir sorumluluk alır.

**Challenges**

Eğer bir banka memuru, bir oto tamircisi ya da bir katip topal bir hata ile karşıma çıkarsa, onlar hakkında ne düşünürsünüz adlı bir soru var konu sonunda. Bu soruyu Türkiye'de on mesleğin dokuzunda gördüğümüz için sadece Teşekkürler diye cevap vererek geçiyorum çünkü yapaleceğimiz bir şey yok. İşte sırf bu sebeple biz bazı şeylerin farkında olan gençler olarak, eğer ortada yanlış bir şey varsa onu kabullenip sonuç üretme mekanizmalı olmalıyız. İşte sırf bu sebeple onların dili eğer kötüyse biz iyi olmalıyız.

### Topic 3 - Software Entropy

Entropi bir sistemde ki düzensizlik miktarını ifade eden bir terimdir. (Sanırsam bu terimi en son lise yıllarımda duydum 🫠) Ancak konuyla bağdaştırınca ne kadarda mantıklı bir yorum haline geliyor. Bizim dilimizde çok güzel bir atasözü var. Üzüm üzüme baka baka kararır diye. Bu cümleyi hiç yazılımla bağdaştırdınız mı?

Eğer bir projede kötü tasarımlar, yanlış kararlar ya da zayıf kodlar varsa ve bunların çözümü için de çözümler tartışılmıyorsa zamanla üzümlerin yavaş yavaş kararması gibi tüm bir projede zamanla körelmeye ve işlevsel olmamaya başlayacaktır.

Çözümler üretilmeli, çözebilecek durum söz konusu değilse  tahtaya yazılıp fikirler tartılışmalı her gün. 

Eğer kendinizi tüm tarafları patlamış bir projenin içerisinde bulursanız, bende onların bu şekilde yazdığı kod gibi yazmaya devam edim, demek çok kolaydır. (Emin olun çok kolay 🥲 Tecrübeyle sabit) Bunun yerine çözümler üretebilmeli ve ortaya bir mimari çıkartabilmek gerekmektedir. Değişimler zordur ancak bir kez değiştikten sonra kimse eskiyi hatırlamamaktadır. Bu konuda birkaç kırık pencere belirleyin ve meslektaşlarınızla durumu tartışın.

**Challenges**

İlk karşılaştığım kırık pencere deneyimi soruyor. Tepkim nasıldı vs. Emin olun hiçbir tepkim olmadı. Ben pandemi öğrencisi oldum. 1. sınıf ve 2. sınıfım pandemide kötü geçti. Kendimi geliştiremedim. 3. sınıfta çalışma hayatı yaşadım ve orada düzensizlik içerisindeyim. Algoritma kurma konusunda bile zorluklar çekerken mimari açıdan kod yazmak hiç bilmiyordum ve bir anda kendimi bir sayfada 3000 - 4000 kodların yazıldığı, design patternlerin, mimarilerin kullanılmadığı bir iş tecrübesi içerisinde oldum. Bu belkide hayatım boyunca hiç unutmayacağım bir tecrübe oldu. Zaten kısa süreli çalıştım ve çıkışım yapıldı. (Birkaç ay)

### Topic 4. Stone Soup and Boiled Frogs

Matrix serisi ilk nasıl çekilmeye başladığını biliyor musunuz? Warner Bros'la görüşmeye gidiyorlar Wachowski kardeşler. Ancak Warner Bros sıcak bakmıyor ve Wachowski kardeşler ısrarcı olduklarında Warner Bros çekelim bu filmi dediklerinde Wachowski kardeşler 80 milyon dolar para istemiş. Warner Bros olur mu ya öyle şey, yuh o para ne. Alın size 10 milyon dolar demiş. Wachowski kardeşler de o parayla sadece ilk 10 dakikayı yapıp göndermişler. Günün sonunda nolmuş derseniz, Warner Bros hayran kalıyor ve istenilen paradan daha fazlasını veriyor.

İşte bazen aynı bu örnekte olduğu gibi kendimize güvenmemiz gerekiyor. Eğer kendimize sonuna kadar inandığımız bir konu varsa, bazen izin almakla, cartla curtla uğraşmayı beklemek anlamsızdır. Üstümüzde ki insanlar sadece başarıyı odak alan insanlar olurlar genellikle. Onların karşısına bir şeyleri yapıp gittiğiniz de, başarınıza ortak olurlar ama şöyle yapıcam, böyle edicem derseniz pek bir anlamı yok maalesef.

Eğer hiçbir şey olmamış gibi devam ederseniz yavaş yavaş sistemin bir kölesi olursunuz. O kadar emin olarak ilerdiğiniz proje, ellerinizden kayıp gider. Günün sonunda mutsuz bir kişilik olur çıkarsınız.

Şuan etrafınızda ne var, üstünüzde kaç ışık kaynağı var, şuan bulunduğunuz odada nerede ne var gibi sorularla etrafınıza inceleyici gözlerle bakmaya çalışın. Etrafınızda olan bitenlere ne kadar hakim olabildiğinizi inceleyin. Aynı şekilde projede de hakim olmaya çalışın. Projeyi benimseyin elinizden geldiğince.

### Topic 5 - Good-Enough Software

Sayfa 50

Shakespeare - ***Striving to better, oft we mar what’s well.*** Daha iyisini çabalarken çoğu zaman iyi olanı bozarız.

Bir müşteri var ve bir ürün talep ediyor. Şu tarihe kadar yetişmesi lazım diyor. Siz eğer şu şu şu özelliklerde olsun derseniz belki ya süreyi yetiştiremeyeceksiniz ya da temel mühendislik kurallarından çıkacak ve yarım bir proje vereceksiniz. Bu hiç profosyonelce bir davranış değil.

Projeyi bir pragrametic programmer olarak yönetmeli ve erken denemesi için bir şeyler sunabilirseniz, bu size geri dönüt noktasında güzel bildirimler sağlayacaktır.

Projelerimizde mimari yapılar uygulamak güzel bir şeydir ancak her projede olmasına gerek yok. Küçük bir projede uygulanması, projeyi gereksiz kafa karışıklığna sebebiyet verecek, proje büyük bir projeyse uygulayın. Gereksiz çok süslemelere hiç gerek yok.

**Challenges**

Yazılım dillerinde, editorlerde, hatta işletim sistemlerinde tüm hataların giderilmiş olmasını beklemeyi mi, karmaşık yazılımların olduğunu ve bazı hataların çözümü yok denilerek kabul edilmesini mi yoksa daha az kusurlu daha basit yazılımları mı tercih edersiniz diye bir soru sorulmuş. Bu soruyu okuduğum zamanlarda ise (31 Ekim 2022) MacOS Ventura işletim sistemi yeni yayınlanmıştı. Bir kaç gün oldu daha. Bazen bilgisayarda sorunlar çıkabiliyor, donma kasma yapabiliyor. Peki bu bir sorun mu, bence hayır. Çünkü kelimenin tek anlamıyla mükemmeli beklemek çok yanlış onun yerine basit hatalar olsa da zamanla çözülebiliyor olması bence yeterli benim için. Yeni güncellemelerle bu sorunlarda gidecek. Ancak hiçbir zaman kusursuz olmayacak.


Diğer bir soru modüleştirme üzerine bir soru soru. Bir projede modüleştirmenin önemli olup olmadığını soruyor. Tabiki de modüleştirme son derece önemli. Bir sayfada 3000 satır kod olması neye yarar, neye çözüm getirebilir? Onun yerine parça parça olsa, yazılan kodları tekrar tekrar tekrar yazmasa projeyi yönetmek çok daha kolay olacak.

Son soruda, 'feature bloat' denilen özellik şişkinliğine hiç rastladın mı tarzında bir soru. Ne demek bu? Mesela bir uygulamada binlerce özellik var ve sen sadece 10-15 tane özellik kullanıyorsun. Diğer her bir özelliğin getirdiği bir ram tüketme, bug oluşturma gibi sorunlar oluştururken sen hiç böyle bir duruma rastladın mı diye bir soru soruluyor. Bu sorunun cevabı elbetteki, evet! Bir telefonda binlerce özellik var ben sadece arama yapıyorum diyelim. Onun yerine 3310 alıp şarjımın 1 ay dayanması daha mantıklı sanki 🥹

### Topic 6 - Your Knowledge Portfolio

Benjamin Franklin - ***An investment in knowledge always pays the best interest*** En iyi faiz, bilgi birikimine yapılan yatırımdır.

Bilginiz sizin portfolyönüzdür. LinkedIn profiliniz, Github profiliniz hiç önemli değil bu sektörde. Şirketler sizin bilginize bakarak işe alır.

* Ciddi yatırımcılar düzenli yatırım yapar. -> alışkanlıklar olarak
* Çeşitlilik anahtar kelimedir. -> uzun dönem başarının
* Akıllı yatırımcılar, riskli ile yüksek kazançlı yatırımlar arasında dengelidir.
* Yatırımcılar düşük gelirli bir şeyden yüksek gelir elde etmeye çalışırlar.
* Portfolyöler düzenli olarak gözden geçirilir ve yeniden şekillenir.

Aslında bu cümleler her şeyi açıklamak için yeterli. Yatırım kendinizsiniz ve kendinize olan yatırımı iyi düşünün. Yatırım sadece dövize ya da hisse senetlerine yapılmaz. (Lafın gelişi diyorum 🤓 bende biliyorum Türkiye'de ev, araba almak çok karlı) En büyük yatırım kendinizsiniz ve mutluluğunuz, hayat kaliteniz buna bağlı.

**Hedefler**

1. Mesela her sene yeni bir dil öğrenin
2. Her ay düzenli teknik kitap okuyun
3. Siz normal kitap da okuyun
4. Ortamlara katılın (Konferans, seminer, bootcamp, sınıflar vs.)
5. Topluluklara katılın (Network ağı dediğimiz olay)
6. Farklı etkinliklere de katıl (iOS Developer'san Android etkinliklerine de katıl)
7. Güncelliğinizi koruyun (Düzenli olarak alanınızda çıkan haberleri, yenilikleri takip edin)

Önünüze fırsatlar çıkacak ancak o fırsatların değerlendirmek için kritik düşünmemiz gerekiyor. Peki Nasıl?

1. 5 neden sor. 5 açıdan neden cevabını değerlendir kendi içinde
2. Kim için yararlı?
3. İçeriği ne?
4. Ne zaman ve Nerede işe yarayacak?
5. Neden böyle bir problem var?

**Challenges**

Yeni bir dil öğrenmeye başla diyor bu hafta. Ancak ben de aşağı yukarı 2 aydır yeni bir dil öğrenmeye başladığım için direk geçiyorum 😉 (Dil tabiki Swift)

Yeni bir kitap okumaya başla ama önce bu kitabı bitir diyor. Elbette ki, zaten şuan bulunduğum [Vakıfbank iOS Bootcamp](https://github.com/ozturkomerfaruk/Patika-Vakifbank-iOS-Bootcamp/tree/master/Kitaplar) sürecinde bir de Clean Code kitabını okuyacağım için kabul ediyorum bunu da.

Bir kafede, bir toplulukta bir etkinliğe katıl diyor. Şuan yine bir bootcamp sürecinde olduğum için otomatik yine bu challenge'ı kabul ediyorum.

### Topic 7 - Communicate!

Mae West - ***I believe that it is better to be looked over than it is to be overlooked*** Göz ardı edilmektense, görmezden gelmenin daha iyi olduğuna inanıyorum.

Bir şirkette en önemli 7 unsur vardır. Bunlar:

1. İletişim
2. İletişim
3. İletişim
4. İletişim
5. İletişim
6. İletişim
7. İletişim

Bilmem anlatabildim mi? Gerçekten espiri niteliğinde bunları yazmıyorum. Bir projeye başlayacaksınız sıfırdan ve bunu büyük bir ekip içerisinde yapıyorsunuz diyelim. Ya mesela yeni Witcher oyununu siz yapacaksınız. Devasa bir oyundan bahsediyoruz. Burada sürekli ekip içerisi toplantılar düzenlenmeli, ses ekibi ayrı, UI Design ekibi ayrı (ve kendi içinde ayrı) Backend ekibi ayrı, frontend ekibi ayrı, satış ekibi ayrı, yönetme ekibi ayrı. Yani biraz düşünürseniz onlarca farklı alan ve her alanda kendi içerisinde ayrılmalardan bahsediyoruz. Bunlar kendi içerisinde iyi bir dinleyici, iyi bir konuşmacı (derdini anlatma konusunda) olmazlarsa bu oyun çıkabilir mi piyasaya? Ayrıca düşünün bunların hepsi tek bir oyun üzerinde çalışıyor. Ancak ses ekibi yazılım ekibiyle beraber uyumlu olmasa ses ekibi yanlış ses design belki yapabilir değil mi? İşte bu sebeple düşünmelisiniz ki, ortada büyük bir dökümantasyon lazım. Dökümantasyon olmadan OLMAAAZ!!!

Dökümantasyon öyle önemli bir şeydir ki, bu projede çalışan yüzlerce insan yarın işten ayrılsa, yeni gelecek yeni yüzlerce insan projeye kaldığı yerden direk başlayabilmesi lazım demektir. Dökümantasyonun olmadığı yerlerde ne oluyor biliyor musunuz? Bunu gözlerimle şahit oldum bir şirkette. İki yazılımcı aynı sayfa tasarımını birbirinden habersiz yapıyor niye dökümantasyon yok ki :) Dökümantasyon hazırlamıyorlar ki :) Farklı zaman dilimlerinde yapmışlar. Boşa vakit kaybı, boşa emek israfı.

**Challenges**

Kitap tavsiyeleri var:

[The Mythical ManMonth: Essays on Software Engineering](https://books.google.com.tr/books?id=Yq35BY5Fk3gC&printsec=frontcover&dq=The+Mythical+Man+Month:+Essays+on+Software+Engineering&hl=en&sa=X&redir_esc=y#v=onepage&q=The%20Mythical%20Man%20Month%3A%20Essays%20on%20Software%20Engineering&f=false)

[Peopleware: Productive Projects and Teams](https://books.google.com.tr/books?id=TVQUAAAAQBAJ&printsec=frontcover&dq=Peopleware:+Productive+Projects+and+Teams&hl=en&sa=X&redir_esc=y#v=onepage&q=Peopleware%3A%20Productive%20Projects%20and%20Teams&f=false)

[Dinosaur Brains: Dealing with All Those Impossible People at Work](https://books.google.com.tr/books?id=_hcJUGQNQi8C&q=Dinosaur+Brains:+Dealing+with+All+Those+Impossible+People+at+Work&dq=Dinosaur+Brains:+Dealing+with+All+Those+Impossible+People+at+Work&hl=en&sa=X&redir_esc=y)

## Chapter 2 - A Pragmatic Approach

İşte başlıyoruz en güzel kısımlara. Bu zamana kadar olan yerler herkesin zaten bildiği (ama bazı şirketlerin ısrarla yapmadığı şeylerdi) şimdi iyi bir yazılımcı olmaya çalışacağız.

### Topic 8 - The Essence of Good Design

Bir uygulama piyasaya çıktıysa ve kullanıcı sayısı fazlaysa, kodları iyi yazılmış demektir. Bu kadar basit mi? Elbette ki, önemli olan son kullanıcıya ulaşması değil mi 🤓 Ancak bir uygulama düşünün ve çok yavaş açılıyor insanlar bundan şikayetçi, burada sorun sizce internette midir yavaş olsun. Hayır uygulama kötü yazılmış demektir.

İyi bir kod yazdığınızın en önemli kanıtları;

* Okunması kolaydır
* Her kod parçacığı değiştirilebilirdir

Bazen her kod parçacığının değiştirilebilir olarak kurmak çok zahmetli olabiliyor ancak hiç önemli değil. Proje büyüdükçe bir şeylerin değiştirilmesi gerektiğini görünce çok kolay yapabiliyor olduğunu farkedeceksin. Ayrıca Unit Test yazmak da çok kolay oluyor.

**Challenges**

Ne düşünüyorsunuz tarzında bir soru var. Ben yaklaşık 1.5 sene Flutter ile uğraştım. Flutter belki de bu kısım için en zirve nokta bile olabilir. Her bir nesne bir Widget denilen yapıdan oluşuyor. Eğer bir kez tekrara düşmek isterseniz projenin belki 1000 farklı yerinde uzun uzadıya kod yazarsınız. Bu yüzden belki de parçalamak Flutter için çok önemli bir şeydir. Bu da benim her dilde alışkanlık haline getirdi. Fonksiyonel ve Nesne Tabana yönelik kod yazmak hayatın en önemli gerçekleridir benim için.

## Topic 9 - DRY - The Evils Of Duplication

Yazılımda baş ucu kelimeniz DRY - ***Don't Repeat Yourself*** olmalıdır. Bol bol fonksiyonerliğinizi artırın. Her şeyi demiyorum ama parçalanabilen her bir kod parçacığını fonksiyonerleştirin.


Ne demektir bu? Her bir yazılan ifade kesin, belirgin olmalı. Tekrara sebebiyet vermemeli. Farklı açılardan irdelenip, tekrarı sağlatmamalı. Test edilirken daha sonra sıkıntısız olmalı. 

***Mesele hatırlamak değil, ne zaman unutacağınız*** Sonra yaparız dediğiniz her şey, sonra yapılmaz!

Bu yözden dolayı DRY - Kod yazmaktan çok daha önemli. Ne kadar iyi yazılımcı olursanız olun, ne kadar aslan, kaplan olursanız olun bir kez DRY'a düşerseniz orada boğulursunuz.

Bu konuyla ilgili bir tane kitap tavsiye ediyor yazar. Nesne taban olarak kodu parçalamak ne demek, fonksiyonerlik olarak parçalamak ne demek detaylı olarak oraya referans ediyor. 

[Object-Oriented Software Construction.](https://books.google.com.tr/books?id=xls_AQAAIAAJ&q=Object-Oriented+Software+Construction.&dq=Object-Oriented+Software+Construction.&hl=en&sa=X&redir_esc=y)

### Topic 10 - Orthogonality

Yazarın kitap tavsiyesi var. [Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design](https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719)

Ortogonal sistem aslında MVVM, MVC, VIPER gibi design patternlerin önemini anlatıyor. Herbir tarafı blok blok yazmanın önemini anlatıyor. Bunun üç açıdan önemi var.

1. Üretkenliği artırmak

Test yazması daha kolay, tekrar kodlanması, tasarım yapılması vs. daha kolay oluyor. Ayrıca eğer kod yazılırken ortogonal şekilde yazılırsa, iki parça ayrı ayrı olduğunda, farklı yerlere vs. kullanmakta daha kolay uyum sağlatır. Öbür türlü bir sayfada 3 bin satır koda doğru merhabaaa!

2. Riski azaltır

Test edilmesi daha kolay cümlesini biraz açacak olursak. Bir kere bir projede test yazmanın önemi çok fazla olduğunu vurgulamıştık. Peki test yazarken nasıl yazacağız? İşte ortogonal bir sistemde test yazacağız. Test yazmanın önemi en çok bu noktada anlaşılıyor. Eğer blok blok her bir kod parçacığı ayrılarak ilerleniyorsa test hem daha kısa sürede yazılır hemde daha başarılı sonuçlar elde ederiz. Öbür türlü durum çok daha karmaşık, çok daha kötü yere gidiyor.

3. Dökümantasyon hazırlanması

İki kardeşin yaşadığı bir ev düşünün. Birinci kardeş, çok düzenli birisi olsun diğeri dağınık. Dağınık olan oda da her şey her yerde iken düzenli odada çamaşırlar dolapta, kitaplar kitaplıkta vs. olsun. Sizin göreviniz iki odaya girip küçük bir kalem pil almak olacak. Hangisinden daha kolay alabilirsiniz sizce?

İşte dökümantasyonun önemi de aynen bu şekilde. Eğer siz 3 bin satırın olduğu onlarca sayfaya girip tek bir sınıftan türeyen nesneye ulaşmaya çalışıyorsanız vay halinize! Ama bütün kodlar blok blok ayrılsa, isterse bin tane sayfa olsa. Ama ayrı ayrı sayfaları dökümantasyon oluşturmak daha kolay. Çok daha hızlı bulursunuz. Zaten 3 bin satırlı onlarca sayfaları kimse dökümantasyon oluşturmaya çalışmıyor. Nasıl edebilirsin ki zaten? Kodlar hep **DRY** prensiplerinden uzak, hiçbir mimari, design pattern yok her şey karmakarışık bide oturup döküman mı hazırlayacan! mehhh! 

### Topic 11 - Reversibility

Emil - Auguste Chartier **Nothing is more dangerous than an idea if it’s the only one you have.** Sahip olduğunuz tek fikir buysa, hiçbir şey bir fikirden daha tehlikeli değildir.

Geleceği tahmin etmek imkansızdır ancak gelecek kaçınılmazdır. Bazı şeyler, bak geliyorum der gibi gelirken bazen de bir anda gelir ve ne olduğunu anlayamayız. Bu yüzden elimizden geldiğince, aslında tedbir alarak yaşamalıyız hayatı, değil mi? Aslında bu davranış, bizim mesleğimiz de kod hayatımızda da geçerli bir durum.

Bir proje düşünün ve bu proje X veri tabanı ile çalışma sergileniyor olsun. Başka bir yerde Y veri tabanı ile aşağı yukarı aynı veri kadar ile farklı bir projede gerçekleşiyor olsun. Y veri tabanı daha hızlı sergileniyor olsun. Bu durumda sistemi değiştirmen ve hızlı adapte olabilen bir sistem kurman gerekiyor. İşte bu durumda 10. Konu ile özdeşleşen bir konunun içerisindeyiz.

Kod yapısı bloklar halinde olmalı ve esnek bir yapıya sahip olmalıdır. Esnek yapıdan kasıt hızlı değiştirilebilir, tersine işlenebilir gibi unsurlardır.

### Topic 12 - Tracer Bullets

Pragmatik programmer olma yolculuğunda bir başka önemli başlık, kodların gözden geçirilme kısmıdır ve kodları yeniden kullanabilir yapmak üzerinedir. Buna kitapta tracer code diyor yazar. Yani iz bırakan kod anlamında. Peki tam manasıyla ne demek bu iz bırakan kod?

Yazılan kod tek kullanımlık değil, tekrar tekrar kullanılabilirdir. Aslında bu konuya Flutter'dan örnek vermek yerinde olacaktır. Flutter'da her şey Widget'lardan oluşuyor doğru. Ancak özelleştirilmiş bir Widget kullanacaksak bunu ayrı bir yerde yazar ve tutardık. Ne zaman kullanmamız gerekiyorsa ona işlevsellik kazandırır ve biryerde hızlıca çağırabilirdik. Özelleştirilmiş Widget'ı tekrar tekrar yazmak yerine hem kodları parçalamaya hem de okunabilirliği artırmaya yönelik bir anlam kazandırmaya çalışırdık. İşte bu işleme bir iz bırakma olayı diyoruz ve gerçekten yerinde bir konu.

Tabi bu sadece basit bir buton örneği diyebiliriz. Tracer kodu daha geniş manada düşünebiliriz. Mesela bir onboarding sayfası diyelim. Onboard sayfası her proje için farklıdır ama özelleştirilebilir tasarlanırsa ve bir kenera konulursa ne zaman istenilip çıkarılmak isteniyorsa çıkarılıp konulabilir.

Bunun çok fazla avantajı var

* Kullanıcı daha performanslı görür projeyi
* Geliştiriciler daha fazla katkıda bulunmaya çalışır.
* Test edilen kod sayısı azalmış olur
* Tracer kod ile, gösterilecek her zaman bir şeyin olur
* Geliştirmek için daha iyi hissedersin kendini

Birde bu kavramı prototiple karıştırmamak lazım. Prototip adı üstünde prototip 🙂 tek kullanımlık kod demek. Proje çıkmadan denemek demek. Tracer code, pasif durumda kod denilebilir. Yeri geldiğinde en sağlam yerinden aktif edilecek kod demek. Zayıf ama zamanı geldiğinde aslan, kaplan olan kod demek.

### Topic 13 - Prototypes and Post-it Notes

Prototip, her üretici firma için olmazsa olmaz kavramıdır. Prototip sayesinde testler yapılır, sonuçlar değerlendirilir, durumlar karşılaştırılır. Peki yazılımda prototip ne anlamlar kazandırır?

* Mimari yapı
* Mevcut sistemde yeni işlevsellikler
* Harici verilerin yapısı ve işlevselliği
* 3. partiler
* performanssal sorunlar
* kullanıcı arayüzü tasarımı

Prototipte peki neleri görmezden gelmeliyiz?

* Dummmy veriler kullanılabilir. Real veri tabanına gerek yok.
* Bütün işlevselliklere gerek yok. Bir parça olsa kafi
* Burada amaç hata bulmak. Kusursuz olmaya gerek yok
* Prototipte amaç testtir. Yorum ve dökman oluştyrmaya çok fazla gerek yok. Ama prototip sonucunda tonlarca belge üretebilirsiniz.

12. konunun sonunda tracer kod ile karşılaştırmıştım. Prototip kodun kullanılma amacı, amacından sapmadan kullanılmalıdır. Prototip kod tek seferlik kullanılan bir koddur. Projede tekrar kullanılma durumu olmamalıdır. Hatalara sebebiyet verebilir, açıklıklara sebebiyet verebilir.

### Topic 14 - Domain Languages

Ludwig Wittgenstein - ***The limits of language are the limits of one’s world.*** Dilin sınırları kişinin dünyasından sınırlıdır.

Müşteriye bir hizmet sunarken bunun açıklamalarını olabildiğince yapmak gerekir.

Rota işlemleri varsa, bunlar detaylı olarak belirtilmeli

yaml dosyasında kullanılan dosyalar belirtilmeli.

Dilin içerisinde eğer yoksa JSON, YAML, CSV gibi dosyalar harici olarak ekleyin ve orada projenizi niteleyin. Orayı bir kimlik olarak düşünün. Zamanınızı çalsa da bu size ileri zamanlarda büyük kolaylık sağlayacak. Bu dosyalara Flutter'dan aşina olmak güzel bir şey benim için. Orada bu dosyalar dilin kendisinde var zaten.

### Topic 15 - Estimating

Pragmatik programmer bir projeye başlamadan önce ekibiyle birlikte projenin tahmin edilebilir türlerini hesaplayarak projeye başlaması gerekmektedir. Bu proje kapsamında projenin ne zaman biteceğini öngörmeli ve ona göre hazırlıklar yapmalıdır.

Projeyi yürütürken bir model oluştur ve o model üzerinden planlar yaparak tahminler yürütmek daha mantıklıdır. 

Burada parametreleri doğru vermek tanımlamada önemlidir. Bu adımda tahmin yeteneğini artırmak mümkünleşiyor.

Tahminleri kaydetmek ve notlar almak, bundan sonraki tahminler için önemli bir kaynak olmaktadır.

Bir ekip içerisinde çalışırken, hangi ekip üyesinin neler yaşadığını normal günlük hayatta bilmeyiz. Hangi ekip üyesinin hangi işi daha hızlı ve daha efektif yapacağını kestirmek gerekmektedir.

Bu konu gerçekten hafife alınacak bir konu değildir. Burada görev veren kişinin biraz oturup, bir kahve yudumlayarak dikkatli bir şekilde düşünmelidir. Bu durumu en iyi gözlemlediğim ortam, daha önce çalıştığım bir şirkette yaşadığım bir polemikti. Bir görev verilmişti ve ben orada daha önce hiçbir işlem yapmamıştım. O teknolojide bir kod bile yazmamıştım. Talep geldi, acil yapman lazım denildi ve hiçbir şey yapamamıştım. Tüm gün bilgisayar ekranına baka kalmıştım. Onun yerine benim görevimi bir başkasına vermek en mantıklı hamle olacaktı ama görevi veren kişi bunu anlamıyordu ve sonuç olarak bir günüm çöp olmuştu.


## Chapter 3

Her çalışan bazı alet edavatlarla çalışır. Bu onların gereksinimleridir. Onlar olmadan o işi yapamazlar. Mesela bir cerrahı düşünecek olursak, onun kullandığı tıbbi dikiş malzemeleri, tıbbi teknolojik aletler; onlar için bilimum önemli aletlerdir.

Bir programcı içinde bu tür gereksinimler söz konusudur. Kullandığımız bir bilgisayardan, kod yazdığım editöre (IDE)'ye kadar her şey bizim göz önümüzdedir ve bizi işimizi yaparken sonuna kadar etkileyen faktörleri içerisinde barındırmaktadır. Şimdi konu konu bunları işlemeye başlayalım.

### Topic 16 - The Power of Plain Text

Bir programcının gücü, dizaynda, gününsonunda ortaya çıkan uygulamada, testlerde ve döküman sayfalarında gizlidir.

Yazılan metnin gücü nedir diye sorulduğunda çıkan 3 madde cevap bulunmaktadır. Bunlar:

* Eskimeye karşı sigorta
* mevcut araçları kullanmaya yönelik
* kolay test edilebilirlik

Burada mesela dışarıdan birisi projeye dahil olduğunda, o proje kapsamında, projeye çok daha hızlı adapte olunabilirlğini göstermektedir.

Mesela bir algoritma yazacaksınız ve bu algoritma Palindrom kelimeleri, cümleleri vs. test edebiliyor olsun. Bu durumda, eğer mevcut bir algoritma varsa o algoritmayı kullanmak en mantıklısıdır. Tekrar tekrar bir şeyi kullanmak yanlıştır. İşte burada bu metinlerin gücünü göstermektedir. Bu geliştiriciye daha fazla imkan tanımaktadır. Düşünmesi gerektiği yerler farklı pencerelerdir. Daha fazla yaratıcılıkla uğraşabilir, burada vaktini sömüren, ırgat mantığı yoktur.

Bu tarz metinlerin en büyük gücü ise, programcılar arasında ortak bir dilin kullanılıyor olmasıdır.

### Topic 17 - Shell Games

Bir futbolcu, sahaya çıkarken sahada performanslı bir oyun sergilemedir. Bu doğru ancak sahaya çıkarken kendini mutlu eden bir hal ile çıkarsa bunu daha iyi yapabilir. Çok uzaklarda aramaya gerek yok, mutluluğu 🤓 Mesela giydiği kramponun rengi, deseni onu iyi hissettirmesine neden olabilir.

Hatta CSGO da iyi bir maç oynamak için, güzel bir bıçak olsa elimizde mesela Butterfly gibi (şimdi fiyatlar uçtu gitti ama olsun örnek bu) oynarken daha bir şevkle oynatıyor insanı. Oysaki bu bıçağın hiçbir etkisi yok oyun oynamada.

İşte programcılar için bu durum söz konusu. Burada kitabın bahsettiği asıl nokta şu: GUI bir kullanıcı için çok faydalı bir şey. Ancak bir geliştirici için insanı körelten bir şey. Biraz elimizi kirletmeli ve kodlarla yönetim yapmalıyız, diyor.

Terminal ekranı da pek sıkıcı be! İşte onu biraz güzelleştirelim diyor.

* Renk temaları ile, keyfine göre ayarlamalar yapabilirsin.
* Prompt ekranında, yani o kod yazılan siyah ekran var ya, özelleştirmeler yapmak, gereksiz şeyleri açmadan kod yazabilmek
* Kodların kısaltmalarını oluşturmak. Basit tags. Örneğin:

``` alias apt-up='sudo apt-get update && sudo apt-get upgrade'```

### Topic 18 - Power Editing

Bir şeyi sürekli tekrarlayıp tecrübe kazanan bir insan, o şeyi çok kısa sürede bitirebilir. Bizim de pragmatic programmer olma amaçlarımızdan birisi, bu akıcılığı kazandırıp bazı şeyleri tekrarlayarak rahata ermemiz. Bunun için birden fazla editor kullanmamız da ya da kullanmamamızda bir sıkıntı yok sadece neyin nasıl olduğunu bilelim yeter.

Mesela örnek verelim. XCode da option tuşuna basarak imleci birden fazla noktada çalıştırabilirsiniz. Bunun inanılmaz büyük bir artısı vardır. Ya da yine XCode da control ve I tuşuna basarsanız Code Formatting yapar. Bunun da etkisi inanılmazdır. Bu tip kolaylıkları keşfederek daha hızlı kod yazabilirsiniz.

### Topic 19 - Version Control

George Santayana - ***Progress, far from consisting in change, depends on retentiveness. Those who cannot remember the past are condemned to repeat it.*** İlerleme, değişimden çok uzak, kalıcılığa bağlıdır. Geçmişi hatırlayamayanlar onu tekrarlamaya mahkumdur.

VCS yani **Version Control System** bir yazılımcı için en önemli araçlardan biridir. Olmazsa olmazımızdır. Hangi yazalım alanı olursa olsun kullanması gereken bir araçtır. Bir zorunluluktur. Kullanılmama gibi ihtimali bile yoktur. Bu kadar önemli bir şey tam olarak nedir? Mesela Git kavramı. Git kavramını herkes duymuştur. İşte Versiyon kontrol sistemimiz mesela budur. Bunun gibi CVS, SVN gibi onlarca var. Ancak en meşhur olan kavram Git dir.

Git üzerinden gidersek eğer, giti yönetebileceğiniz siteler bulunmaktadır. Github, Bitbucket, Gitlab gibi.

Peki ne işe yarar bu? En büyük avantajı yazdığınız kodlar bir yerde saklanmaktadır. Mesela bir projeye geliştirmeye başladınız. Projenizi sürekli pcde tutmanıza gerek yok at Git'e at orda dursun. Arkadaşlarınızla beraber proje mi geliştiriyorsunuz? Github kullanmak **ZORUNLU** Yoksa ne yapacaksınız? Whatsapp da birbirinize tek tek zip halinde projeyi mi atacaksınız? onun yerine 2 satır kodla Git'e atıp çekmek dururken. Hatta Git tool'ları sayesinde 1 tuşla her şeyi yapabiliyorsunuz. Mesela Sourcetree gibi ya da Github kendi tool'u bulunmakta, o da güzel.

Bu konuyu uzun uzadıya yazmak mümkün ancak ben blog sayfamda bahsetmiştim. Onun linki için [tıklayınız.] (https://ozturkomerfaruk.com/git-komutlari-ve-kullanimi-her-sey/)

### Topic 20 - Debugging

Debug etmek deyimi, gerçekten yazılımcıların günlük hayatta kullandığı belki en sık deyimdir. Sürekli çıkan hataları çözme konusunda belki de en gerçekçi yöntemdir. Ayrıca benim için IDE'yi IDE yapan Debug ederken verilen ayrıntıların güzelliğidir. Her IDE maalesef aynı şekilde sonuçları vermiyor.

Şimdi adım adım Debug etmek nasıl yapılıyor, bir örnek üzerinden gideceğiz.

1. Android Stuido üzerinde Flutter'da bir proje geliştiriyoruz. API'dan veri çekeceğiz ve ekrana bastıracağız. Ancak veriler gelmiyor, sorun ne olabilir diyoruz?
2. Ekrana bastırdığımız UI tool'una debug point'i koyuyoruz. O tool'a ulaşan controller'a koyuyoruz. Controller'a giden API fetch ettiğimiz url'ye koyuyoruz.
3. Sırayla Debugları çalıştıracağız. İlk başta UIButton'un çalıştığını görüyoruz ancak veri gelmiyor. Controller'a da veri gelmiyor. Öyleyse API'da ya bir sıkıntı var ya da verileri doğru çekemiyoruz diyoruz.
4. API da gelen url'yi kontrol ederken bakıyoruz. Status 200 mü dönmüş. Hayırsa sorun ya url yi yanlış yazdık ya o tarafta bir sıkıntı var. Bu 200 vs. nedir diye soracak olursanız. [Şuraya](https://ozturkomerfaruk.com/http-durum-kodlari-nelerdir/) tıklayabilirsiniz.
5. Sonra adım adım çözüm yapmaya başlıyoruz.

Ayrıca API'da gelen statuyu kontrol ederken gelen verinin neler getirdiğini de detaylıca görebilirsiniz. Çok büyük bir projede çalışıyorsanız, gelen verinin illa bir yerlere bastırarak görmek zorunda değilsiniz. Mesela Debug ettiniz ve kocaman bir JSON dosyası çıktı. Bunun modelini oluşturacaksınız. Tek tek oluşturmaya ne gerek var. Debug da JSON dosyasını kopyala, al örneğin JSON to Dart yaz internete. İnternette çıkan Model oluşturma sitelerinden birini gir dönüştür kopyala projeye yapıştır düzenlemelerini yap.

Debug da her detayı aslında görmek mümkün. Tabi dilden dile, framework'ten framework'e, editörden editöre çok şey değişse de Debug etmek her alan için söz konusu. Bu alanda yazılan yazılar, çıkan notlar vs. hep söz olup uçup gidiyor. Çalıştığınız editörün ve dilin tüm Debug özelliklerini keşfedin

### Topic 21 - Text Manipulation




